import {
  require_dist as require_dist3
} from "./chunk-R6RVWVMA.js";
import {
  require_dist as require_dist2
} from "./chunk-XXAOEBEW.js";
import {
  require_dist
} from "./chunk-S6ZVDFYS.js";
import {
  require_asn1,
  require_elliptic,
  require_hash
} from "./chunk-E7VVHVVU.js";
import {
  require_buffer
} from "./chunk-JRORZOUI.js";
import {
  require_des
} from "./chunk-SOLOT4I4.js";
import {
  __commonJS
} from "./chunk-TDUMLE5V.js";

// node_modules/js-crypto-key-utils/dist/params.js
var require_params = __commonJS({
  "node_modules/js-crypto-key-utils/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlgorithmFromOidStrict = exports.getAlgorithmFromOid = exports.hashes = exports.encryptionSchemes = exports.pbkdf2Prfs = exports.keyDerivationFunctions = exports.passwordBasedEncryptionSchemes = exports.publicKeyAlgorithms = exports.namedCurves = void 0;
    exports.namedCurves = {
      "P-256": { indutnyName: "p256", payloadSize: 32, oid: [1, 2, 840, 10045, 3, 1, 7] },
      "P-384": { indutnyName: "p384", payloadSize: 48, oid: [1, 3, 132, 0, 34] },
      "P-521": { indutnyName: "p521", payloadSize: 66, oid: [1, 3, 132, 0, 35] },
      "P-256K": { indutnyName: "secp256k1", payloadSize: 32, oid: [1, 3, 132, 0, 10] }
    };
    exports.publicKeyAlgorithms = {
      "EC": { oid: [1, 2, 840, 10045, 2, 1] },
      "RSA": { oid: [1, 2, 840, 113549, 1, 1, 1] }
    };
    exports.passwordBasedEncryptionSchemes = {
      // PBES1
      "pbeWithMD5AndDES-CBC": { oid: [1, 2, 840, 113549, 1, 5, 3], hash: "MD5", encrypt: "DES-CBC" },
      "pbeWithSHA1AndDES-CBC": { oid: [1, 2, 840, 113549, 1, 5, 10], hash: "SHA-1", encrypt: "DES-CBC" },
      // PBES2
      "pbes2": { oid: [1, 2, 840, 113549, 1, 5, 13] }
    };
    exports.keyDerivationFunctions = {
      "pbkdf2": { oid: [1, 2, 840, 113549, 1, 5, 12], defaultSaltLen: 8 }
    };
    exports.pbkdf2Prfs = {
      "hmacWithSHA1": { oid: [1, 2, 840, 113549, 2, 7], hash: "SHA-1" },
      "hmacWithSHA256": { oid: [1, 2, 840, 113549, 2, 9], hash: "SHA-256" },
      "hmacWithSHA384": { oid: [1, 2, 840, 113549, 2, 10], hash: "SHA-384" },
      "hmacWithSHA512": { oid: [1, 2, 840, 113549, 2, 11], hash: "SHA-512" }
    };
    exports.encryptionSchemes = {
      "des-ede3-cbc": { oid: [1, 2, 840, 113549, 3, 7], keyLength: 24, ivLength: 8 },
      "aes128-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 2], keyLength: 16, ivLength: 16 },
      "aes192-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 22], keyLength: 24, ivLength: 16 },
      "aes256-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 42], keyLength: 32, ivLength: 16 }
    };
    exports.hashes = {
      "SHA-256": { hashSize: 32 },
      "SHA-384": { hashSize: 48 },
      "SHA-512": { hashSize: 64 },
      "SHA-1": { hashSize: 20 },
      "MD5": { hashSize: 16 }
      // SHOULD NOT USE
    };
    function getAlgorithmFromOid(oid, oidDict) {
      return Object.keys(oidDict).filter(function(k) {
        return oidDict[k].oid.toString() === oid.toString();
      });
    }
    exports.getAlgorithmFromOid = getAlgorithmFromOid;
    var getAlgorithmFromOidStrict = function(oid, dict) {
      var array = getAlgorithmFromOid(oid, dict);
      if (array.length === 0)
        throw new Error("UnsupportedAlgorithm");
      return array[0];
    };
    exports.getAlgorithmFromOidStrict = getAlgorithmFromOidStrict;
  }
});

// node_modules/js-encoding-utils/dist/src/env.js
var require_env = __commonJS({
  "node_modules/js-encoding-utils/dist/src/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvAtob = exports.getEnvBtoa = void 0;
    var getEnvBtoa = () => {
      if (typeof window !== "undefined")
        return window.btoa;
      else
        return nodeBtoa;
    };
    exports.getEnvBtoa = getEnvBtoa;
    var getEnvAtob = () => {
      if (typeof window !== "undefined")
        return window.atob;
      else
        return nodeAtob;
    };
    exports.getEnvAtob = getEnvAtob;
    var nodeBtoa = (str) => {
      if (typeof Buffer === "undefined")
        throw new Error("UnsupportedEnvironment");
      const buffer = Buffer.from(str.toString(), "binary");
      return buffer.toString("base64");
    };
    var nodeAtob = (str) => {
      if (typeof Buffer === "undefined")
        throw new Error("UnsupportedEnvironment");
      return Buffer.from(str, "base64").toString("binary");
    };
  }
});

// node_modules/js-encoding-utils/dist/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/js-encoding-utils/dist/src/encoder.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToArrayBuffer = exports.arrayBufferToString = exports.hexStringToArrayBuffer = exports.arrayBufferToHexString = exports.decodeBase64Url = exports.encodeBase64Url = exports.decodeBase64 = exports.encodeBase64 = void 0;
    var env = __importStar(require_env());
    var encodeBase64 = (data) => {
      let str = "";
      if (typeof data === "string")
        str = data;
      else
        str = (0, exports.arrayBufferToString)(data);
      const btoa = env.getEnvBtoa();
      return btoa(str);
    };
    exports.encodeBase64 = encodeBase64;
    var decodeBase64 = (str) => {
      const atob = env.getEnvAtob();
      const binary = atob(str);
      const data = (0, exports.stringToArrayBuffer)(binary);
      return getAsciiIfAscii(data);
    };
    exports.decodeBase64 = decodeBase64;
    var sanitizeTypedArrayAndArrayBuffer = (data) => {
      if (data instanceof Uint8Array)
        return data;
      if (ArrayBuffer.isView(data) && typeof data.buffer !== "undefined") {
        return new Uint8Array(data.buffer);
      } else
        return new Uint8Array(data);
    };
    var getAsciiIfAscii = (data) => {
      let flag = true;
      for (let i = 0; i < data.length; i++) {
        if (data[i] > 126 || data[i] < 32 && data[i] !== 13 && data[i] !== 10) {
          flag = false;
          break;
        }
      }
      let returnData = null;
      if (flag) {
        returnData = "";
        for (let i = 0; i < data.length; i++)
          returnData += String.fromCharCode(data[i]);
      } else
        returnData = data;
      return returnData;
    };
    var encodeBase64Url = (data) => (0, exports.encodeBase64)(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    exports.encodeBase64Url = encodeBase64Url;
    var decodeBase64Url = (str) => {
      str = str.replace(/-/g, "+").replace(/_/g, "/");
      return (0, exports.decodeBase64)(str);
    };
    exports.decodeBase64Url = decodeBase64Url;
    var arrayBufferToHexString = (data) => {
      const arr = sanitizeTypedArrayAndArrayBuffer(data);
      let hexStr = "";
      for (let i = 0; i < arr.length; i++) {
        let hex = (arr[i] & 255).toString(16);
        hex = hex.length === 1 ? `0${hex}` : hex;
        hexStr += hex;
      }
      return hexStr;
    };
    exports.arrayBufferToHexString = arrayBufferToHexString;
    var hexStringToArrayBuffer = (str) => {
      const arr = [];
      const len = str.length;
      for (let i = 0; i < len; i += 2)
        arr.push(parseInt(str.substr(i, 2), 16));
      return new Uint8Array(arr);
    };
    exports.hexStringToArrayBuffer = hexStringToArrayBuffer;
    var arrayBufferToString = (data) => {
      const bytes = sanitizeTypedArrayAndArrayBuffer(data);
      const arr = new Array(bytes.length);
      bytes.forEach((x, i) => {
        arr[i] = x;
      });
      return String.fromCharCode.apply(null, arr);
    };
    exports.arrayBufferToString = arrayBufferToString;
    var stringToArrayBuffer = (str) => {
      const bytes = new Uint8Array(str.length);
      return bytes.map((_x, i) => str.charCodeAt(i));
    };
    exports.stringToArrayBuffer = stringToArrayBuffer;
  }
});

// node_modules/js-encoding-utils/dist/src/formatter.js
var require_formatter = __commonJS({
  "node_modules/js-encoding-utils/dist/src/formatter.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.binToPem = exports.pemToBin = void 0;
    var encoder = __importStar(require_encoder());
    var PemArmorString = {
      "public": "PUBLIC KEY",
      "private": "PRIVATE KEY",
      "encryptedPrivate": "ENCRYPTED PRIVATE KEY",
      "certificate": "CERTIFICATE",
      "certRequest": "CERTIFICATE REQUEST"
    };
    var pemToBin = (keydataB64Pem) => {
      const keydataB64 = dearmorPem(keydataB64Pem);
      return encoder.decodeBase64(keydataB64);
    };
    exports.pemToBin = pemToBin;
    var binToPem = (keydata, type) => {
      const keydataB64 = encoder.encodeBase64(keydata);
      return formatAsPem(keydataB64, type);
    };
    exports.binToPem = binToPem;
    var formatAsPem = (str, type) => {
      const typeString = PemArmorString[type];
      let finalString = `-----BEGIN ${typeString}-----
`;
      while (str.length > 0) {
        finalString += `${str.substring(0, 64)}
`;
        str = str.substring(64);
      }
      finalString = `${finalString}-----END ${typeString}-----`;
      return finalString;
    };
    var dearmorPem = (str) => {
      const beginRegExp = RegExp("^-----[s]*BEGIN[^-]*-----$", "gm");
      const endRegExp = RegExp("^-----[s]*END[^-]*-----$", "gm");
      try {
        let dearmored = str.split(beginRegExp)[1].split(endRegExp)[0];
        dearmored = dearmored.replace(/\r?\n/g, "");
        return dearmored;
      } catch (e) {
        throw new Error("Invalid format as PEM");
      }
    };
  }
});

// node_modules/js-encoding-utils/dist/src/index.js
var require_src = __commonJS({
  "node_modules/js-encoding-utils/dist/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatter = exports.encoder = void 0;
    var Encoder = __importStar(require_encoder());
    var Formatter = __importStar(require_formatter());
    var encoder;
    (function(encoder2) {
      encoder2.encodeBase64 = Encoder.encodeBase64;
      encoder2.decodeBase64 = Encoder.decodeBase64;
      encoder2.encodeBase64Url = Encoder.encodeBase64Url;
      encoder2.decodeBase64Url = Encoder.decodeBase64Url;
      encoder2.arrayBufferToHexString = Encoder.arrayBufferToHexString;
      encoder2.hexStringToArrayBuffer = Encoder.hexStringToArrayBuffer;
      encoder2.stringToArrayBuffer = Encoder.stringToArrayBuffer;
      encoder2.arrayBufferToString = Encoder.arrayBufferToString;
    })(encoder || (exports.encoder = encoder = {}));
    var formatter;
    (function(formatter2) {
      formatter2.binToPem = Formatter.binToPem;
      formatter2.pemToBin = Formatter.pemToBin;
    })(formatter || (exports.formatter = formatter = {}));
    exports.default = { encoder, formatter };
  }
});

// node_modules/js-crypto-key-utils/dist/asn1def.js
var require_asn1def = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1def.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PBES2ESParams = exports.PBKDF2Params = exports.PBES2Params = exports.PBEParameter = exports.EncryptedPrivateKeyInfo = exports.OneAsymmetricKey = exports.SubjectPublicKeyInfo = exports.KeyStructure = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    exports.KeyStructure = asn1_js_1.default.define("KeyStructure", function() {
      this.choice({
        // @ts-ignore
        subjectPublicKeyInfo: this.use(exports.SubjectPublicKeyInfo),
        // @ts-ignore
        oneAsymmetricKey: this.use(exports.OneAsymmetricKey),
        // @ts-ignore
        encryptedPrivateKeyInfo: this.use(exports.EncryptedPrivateKeyInfo)
      });
    });
    exports.SubjectPublicKeyInfo = asn1_js_1.default.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("algorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("subjectPublicKey").bitstr()
      );
    });
    exports.OneAsymmetricKey = asn1_js_1.default.define("OneAsymmetricKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").use(Version),
        // @ts-ignore
        this.key("privateKeyAlgorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // @ts-ignore
        this.key("attributes").implicit(0).optional().any(),
        // @ts-ignore
        this.key("publicKey").implicit(1).optional().bitstr()
      );
    });
    exports.EncryptedPrivateKeyInfo = asn1_js_1.default.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("encryptionAlgorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("encryptedData").octstr()
      );
    });
    exports.PBEParameter = asn1_js_1.default.define("PBEParameter", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("salt").octstr(8),
        // @ts-ignore
        this.key("iterationCount").int()
      );
    });
    exports.PBES2Params = asn1_js_1.default.define("PBES2Params", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("keyDerivationFunc").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("encryptionScheme").use(AlgorithmIdentifier)
      );
    });
    exports.PBKDF2Params = asn1_js_1.default.define("PBKDF2Params", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("salt").choice({
          // @ts-ignore
          "specified": this.octstr(),
          // @ts-ignore
          "otherSource": this.use(AlgorithmIdentifier)
        }),
        // @ts-ignore
        this.key("iterationCount").int(),
        // @ts-ignore
        this.key("keyLength").int().optional(),
        // @ts-ignore
        this.key("prf").use(AlgorithmIdentifier).def({
          algorithm: [1, 2, 840, 113549, 2, 7],
          parameters: Buffer.from([5, 0])
        })
      );
    });
    exports.PBES2ESParams = {
      "des-ede3-cbc": asn1_js_1.default.define("DesEde3CbcParams", function() {
        this.octstr();
      }),
      "aes128-cbc": asn1_js_1.default.define("Aes128CbcParams", function() {
        this.octstr();
      }),
      "aes192-cbc": asn1_js_1.default.define("Aes192CbcParams", function() {
        this.octstr();
      }),
      "aes256-cbc": asn1_js_1.default.define("Aes256CbcParams", function() {
        this.octstr();
      })
    };
    var AlgorithmIdentifier = asn1_js_1.default.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("algorithm").objid(),
        // @ts-ignore
        this.key("parameters").optional().any()
      );
    });
    var Version = asn1_js_1.default.define("Version", function() {
      this.int();
    });
  }
});

// node_modules/js-crypto-key-utils/dist/util.js
var require_util = __commonJS({
  "node_modules/js-crypto-key-utils/dist/util.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.appendLeadingZeros = exports.pruneLeadingZeros = exports.getJwkType = exports.getSec1KeyType = exports.getAsn1KeyType = exports.isAsn1Public = exports.isAsn1Encrypted = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var params = __importStar(require_params());
    var asn1def_1 = require_asn1def();
    var isAsn1Encrypted = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var keyType;
      try {
        keyType = (0, exports.getAsn1KeyType)(key, format);
      } catch (e) {
        return false;
      }
      return keyType === "encryptedPrivate";
    };
    exports.isAsn1Encrypted = isAsn1Encrypted;
    var isAsn1Public = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var keyType;
      try {
        keyType = (0, exports.getAsn1KeyType)(key, format);
      } catch (e) {
        return false;
      }
      return keyType === "public";
    };
    exports.isAsn1Public = isAsn1Public;
    var getAsn1KeyType = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var binKey = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(key) : key;
      var decoded = asn1def_1.KeyStructure.decode(Buffer.from(binKey), "der");
      if (decoded.type === "encryptedPrivateKeyInfo")
        return "encryptedPrivate";
      else if (decoded.type === "oneAsymmetricKey")
        return "private";
      else if (decoded.type === "subjectPublicKeyInfo")
        return "public";
      else
        throw new Error("NotSpkiNorPkcs8Key");
    };
    exports.getAsn1KeyType = getAsn1KeyType;
    var getSec1KeyType = function(sec1key, namedCurve) {
      var len = params.namedCurves[namedCurve].payloadSize;
      var binKey = sec1key instanceof Uint8Array ? sec1key : js_encoding_utils_1.default.encoder.hexStringToArrayBuffer(sec1key);
      if (binKey.length <= len)
        return "private";
      else if (binKey.length === 2 * len + 1 && binKey[0] === 4 || binKey.length === len + 1 && (binKey[0] === 2 || binKey[0] === 3))
        return "public";
      else
        throw new Error("UnsupportedKeyStructure");
    };
    exports.getSec1KeyType = getSec1KeyType;
    var getJwkType = function(jwkey) {
      if (jwkey.kty === "EC") {
        if (jwkey.x && jwkey.y && jwkey.d)
          return "private";
        else if (jwkey.x && jwkey.y)
          return "public";
        else
          throw new Error("InvalidECKey");
      } else if (jwkey.kty === "RSA") {
        if (jwkey.n && jwkey.e && jwkey.d && jwkey.p && jwkey.q && jwkey.dp && jwkey.dq && jwkey.qi)
          return "private";
        else if (jwkey.n && jwkey.e)
          return "public";
        else
          throw new Error("InvalidRSAKey");
      } else
        throw new Error("UnsupportedJWKType");
    };
    exports.getJwkType = getJwkType;
    var pruneLeadingZeros = function(array) {
      var offset = 0;
      for (var i = 0; i < array.length; i++) {
        if (array[i] !== 0)
          break;
        offset++;
      }
      var returnArray = new Uint8Array(array.length - offset);
      returnArray.set(array.slice(offset, array.length));
      return returnArray;
    };
    exports.pruneLeadingZeros = pruneLeadingZeros;
    var appendLeadingZeros = function(array, len) {
      if (array.length > len)
        throw new Error("InvalidLength");
      var returnArray = new Uint8Array(len);
      returnArray.set(array, len - array.length);
      return returnArray;
    };
    exports.appendLeadingZeros = appendLeadingZeros;
  }
});

// node_modules/js-crypto-key-utils/dist/octenc.js
var require_octenc = __commonJS({
  "node_modules/js-crypto-key-utils/dist/octenc.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var params = __importStar(require_params());
    var js_encoding_utils_1 = __importDefault(require_src());
    var elliptic = __importStar(require_elliptic());
    var util_1 = require_util();
    var Ec = elliptic.ec;
    var fromJwk = function(jwkey, _a) {
      var outputPublic = _a.outputPublic, _b = _a.outputFormat, outputFormat = _b === void 0 ? "binary" : _b, _c = _a.compact, compact = _c === void 0 ? false : _c;
      var orgType = (0, util_1.getJwkType)(jwkey);
      var type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
      if (type === "public") {
        var bufX = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.x);
        var bufY = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.y);
        var publicKey = void 0;
        if (compact) {
          publicKey = new Uint8Array(bufX.length + 1);
          publicKey[0] = 255 & (1 & bufY.slice(-1)[0]) + 2;
          publicKey.set(bufX, 1);
        } else {
          publicKey = new Uint8Array(bufX.length + bufY.length + 1);
          publicKey[0] = 255 & 4;
          publicKey.set(bufX, 1);
          publicKey.set(bufY, bufX.length + 1);
        }
        return outputFormat === "string" ? js_encoding_utils_1.default.encoder.arrayBufferToHexString(publicKey) : publicKey;
      } else {
        if (!jwkey.d)
          throw new Error("InvalidKey");
        var bufD = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.d);
        return outputFormat === "string" ? js_encoding_utils_1.default.encoder.arrayBufferToHexString(bufD) : bufD;
      }
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(octkey, namedCurve, _a) {
      var outputPublic = _a.outputPublic;
      if (Object.keys(params.namedCurves).indexOf(namedCurve) < 0)
        throw new Error("UnsupportedCurve");
      var orgType = (0, util_1.getSec1KeyType)(octkey, namedCurve);
      var type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
      var binKey = typeof octkey === "string" ? js_encoding_utils_1.default.encoder.hexStringToArrayBuffer(octkey) : octkey;
      var curve = params.namedCurves[namedCurve].indutnyName;
      var ec = new Ec(curve);
      var ecKey = orgType === "public" ? ec.keyFromPublic(binKey) : ec.keyFromPrivate(binKey);
      var publicKey = new Uint8Array(ecKey.getPublic("array"));
      var len = params.namedCurves[namedCurve].payloadSize;
      var bufX = publicKey.slice(1, len + 1);
      var bufY = publicKey.slice(len + 1, len * 2 + 1);
      var jwKey = {
        kty: "EC",
        crv: namedCurve,
        x: js_encoding_utils_1.default.encoder.encodeBase64Url(bufX),
        y: js_encoding_utils_1.default.encoder.encodeBase64Url(bufY)
        // ext: true
      };
      if (type === "private") {
        jwKey.d = js_encoding_utils_1.default.encoder.encodeBase64Url(binKey);
      }
      return jwKey;
    };
    exports.toJwk = toJwk;
  }
});

// node_modules/js-crypto-key-utils/dist/asn1ec.js
var require_asn1ec = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1ec.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJWK = exports.fromJWK = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    var params = __importStar(require_params());
    var octenc_1 = require_octenc();
    var fromJWK = function(jwk, type, compact) {
      if (compact === void 0) {
        compact = false;
      }
      var octetPublicKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: "binary", outputPublic: true, compact });
      var publicKeyAlgorithmOid = params.publicKeyAlgorithms["EC"].oid;
      var publicKey = { unused: 0, data: Array.from(octetPublicKey) };
      var parameters = ECParameters.encode({ type: "namedCurve", value: params.namedCurves[jwk.crv].oid }, "der");
      var algorithm = { algorithm: publicKeyAlgorithmOid, parameters };
      var decoded = {};
      if (type === "public") {
        decoded.subjectPublicKey = publicKey;
        decoded.algorithm = algorithm;
      } else if (type === "private") {
        var octetPrivateKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: "binary", outputPublic: false, compact });
        decoded.version = 0;
        decoded.privateKeyAlgorithm = algorithm;
        decoded.privateKey = ECPrivateKey.encode({
          version: 1,
          privateKey: Array.from(octetPrivateKey),
          parameters,
          publicKey
        }, "der");
      }
      return decoded;
    };
    exports.fromJWK = fromJWK;
    var toJWK = function(decoded, type) {
      if (type === "public") {
        decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, "der");
        var octPubKey = new Uint8Array(decoded.subjectPublicKey.data);
        var namedCurves = params.getAlgorithmFromOid(decoded.algorithm.parameters.value, params.namedCurves);
        return (0, octenc_1.toJwk)(octPubKey, namedCurves[0], { outputPublic: true });
      } else {
        decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, "der");
        try {
          decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, "der");
        } catch (e) {
          decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, "der");
        }
        var octPrivKey = new Uint8Array(decoded.privateKey.privateKey);
        var namedCurves = params.getAlgorithmFromOid(decoded.privateKeyAlgorithm.parameters.value, params.namedCurves);
        if (namedCurves.length < 1)
          throw new Error("UnsupportedCurve");
        return (0, octenc_1.toJwk)(octPrivKey, namedCurves[0], { outputPublic: false });
      }
    };
    exports.toJWK = toJWK;
    var ECParameters = asn1_js_1.default.define("ECParameters", function() {
      this.choice({
        // @ts-ignore
        namedCurve: this.objid()
      });
    });
    var ECPrivateKey = asn1_js_1.default.define("ECPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // @ts-ignore
        this.key("parameters").explicit(0).optional().any(),
        // rfc suggested that this must be implemented
        // @ts-ignore
        this.key("publicKey").explicit(1).optional().bitstr()
        // rfc suggested that this must be implemented
      );
    });
    var ECPrivateKeyAlt = asn1_js_1.default.define("ECPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
        // @ts-ignore
        this.key("publicKey").explicit(1).optional().bitstr()
        // rfc suggested that this must be implemented
      );
    });
  }
});

// node_modules/js-crypto-key-utils/dist/asn1rsa.js
var require_asn1rsa = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1rsa.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    var js_encoding_utils_1 = __importDefault(require_src());
    var BufferMod = __importStar(require_buffer());
    var Buffer2 = BufferMod.Buffer;
    var params = __importStar(require_params());
    var util_1 = require_util();
    var fromJwk = function(jwk, type) {
      var publicKeyAlgorithmOid = params.publicKeyAlgorithms["RSA"].oid;
      var parameters = Buffer2.from([5, 0]);
      var algorithm = { algorithm: publicKeyAlgorithmOid, parameters };
      var modulusBytes = js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.n);
      var nLen = modulusBytes.length;
      var modulusLength = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
      var modulus = new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(modulusBytes, modulusLength));
      var publicExponent = new asn1_js_1.default.bignum(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.e));
      var decoded = {};
      if (type === "public") {
        decoded.subjectPublicKey = {
          unused: 0,
          data: RSAPublicKey.encode({ modulus, publicExponent }, "der")
        };
        decoded.algorithm = algorithm;
      } else if (type === "private") {
        decoded.version = 0;
        decoded.privateKeyAlgorithm = algorithm;
        decoded.privateKey = RSAPrivateKey.encode({
          version: 0,
          modulus,
          publicExponent,
          privateExponent: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.d), modulusLength)),
          prime1: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.p), modulusLength)),
          prime2: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.q), modulusLength)),
          exponent1: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.dp), modulusLength)),
          exponent2: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.dq), modulusLength)),
          coefficient: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.qi), modulusLength))
        }, "der");
      }
      return decoded;
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(decoded, type) {
      if (type === "public") {
        decoded.subjectPublicKey.data = RSAPublicKey.decode(decoded.subjectPublicKey.data, "der");
        var modulus = decoded.subjectPublicKey.data.modulus;
        var publicExponent = decoded.subjectPublicKey.data.publicExponent;
        var nLen = modulus.byteLength();
        var len = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
        modulus = new Uint8Array(modulus.toArray("be", len));
        publicExponent = new Uint8Array(publicExponent.toArray("be", publicExponent.byteLength()));
        return {
          kty: "RSA",
          n: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(modulus)),
          e: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(publicExponent))
        };
      } else {
        decoded.privateKey = RSAPrivateKey.decode(decoded.privateKey, "der");
        var privateKeyElems_1 = {};
        privateKeyElems_1.modulus = decoded.privateKey.modulus;
        var nLen = privateKeyElems_1.modulus.byteLength();
        var len_1 = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
        privateKeyElems_1.modulus = new Uint8Array(privateKeyElems_1.modulus.toArray("be", len_1));
        privateKeyElems_1.publicExponent = new Uint8Array(decoded.privateKey.publicExponent.toArray("be", decoded.privateKey.publicExponent.byteLength()));
        privateKeyElems_1.privateExponent = new Uint8Array(decoded.privateKey.privateExponent.toArray("be", len_1));
        var keys = ["prime1", "prime2", "exponent1", "exponent2", "coefficient"];
        keys.forEach(function(key) {
          privateKeyElems_1[key] = new Uint8Array(decoded.privateKey[key].toArray("be", len_1 >> 1));
        });
        return {
          kty: "RSA",
          n: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.modulus)),
          e: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.publicExponent)),
          d: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.privateExponent)),
          p: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.prime1)),
          q: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.prime2)),
          dp: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.exponent1)),
          dq: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.exponent2)),
          qi: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.coefficient))
        };
      }
    };
    exports.toJwk = toJwk;
    var RSAPublicKey = asn1_js_1.default.define("RSAPublicKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("modulus").int(),
        // n
        // @ts-ignore
        this.key("publicExponent").int()
        // e
      );
    });
    var RSAPrivateKey = asn1_js_1.default.define("RSAPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // 0
        // @ts-ignore
        this.key("modulus").int(),
        // n
        // @ts-ignore
        this.key("publicExponent").int(),
        // e
        // @ts-ignore
        this.key("privateExponent").int(),
        // d
        // @ts-ignore
        this.key("prime1").int(),
        // p
        // @ts-ignore
        this.key("prime2").int(),
        // q
        // @ts-ignore
        this.key("exponent1").int(),
        // d mod (p-1)
        // @ts-ignore
        this.key("exponent2").int(),
        // d mod (q-1)
        // @ts-ignore
        this.key("coefficient").int(),
        // (inverse of q) mod p
        // @ts-ignore
        this.key("otherPrimeInfos").optional().use(OtherPrimeInfos)
      );
    });
    var OtherPrimeInfos = asn1_js_1.default.define("OtherPrimeInfos", function() {
      this.seqof(OtherPrimeInfo);
    });
    var OtherPrimeInfo = asn1_js_1.default.define("OtherPrimeInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("prime").int(),
        // @ts-ignore
        this.key("exponent").int(),
        // @ts-ignore
        this.key("coefficient").int()
      );
    });
  }
});

// node_modules/js-crypto-hash/dist/params.js
var require_params2 = __commonJS({
  "node_modules/js-crypto-hash/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { nodeName: "sha3-512", hashSize: 64 },
        "SHA3-384": { nodeName: "sha3-384", hashSize: 48 },
        "SHA3-256": { nodeName: "sha3-256", hashSize: 32 },
        "SHA3-224": { nodeName: "sha3-224", hashSize: 28 },
        "SHA-256": { nodeName: "sha256", hashSize: 32 },
        "SHA-384": { nodeName: "sha384", hashSize: 48 },
        "SHA-512": { nodeName: "sha512", hashSize: 64 },
        "SHA-1": { nodeName: "sha1", hashSize: 20 },
        "MD5": { nodeName: "md5", hashSize: 16 }
        // SHOULD NOT USE
      }
    };
    exports.default = params;
  }
});

// node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "node_modules/crypt/crypt.js"(exports, module) {
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        // Bit-wise rotation left
        rotl: function(n, b) {
          return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
          return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
          }
          for (var i = 0; i < n.length; i++)
            n[i] = crypt.endian(n[i]);
          return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
          for (var bytes = []; n > 0; n--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 15).toString(16));
          }
          return hex.join("");
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0)
              continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module.exports = crypt;
    })();
  }
});

// node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "node_modules/charenc/charenc.js"(exports, module) {
    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 255);
          return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join("");
        }
      }
    };
    module.exports = charenc;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/md5/md5.js
var require_md5 = __commonJS({
  "node_modules/md5/md5.js"(exports, module) {
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md5 = function(message, options) {
        if (message.constructor == String)
          if (options && options.encoding === "binary")
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
          message = message.toString();
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (var i = 0; i < m.length; i++) {
          m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
        }
        m[l >>> 5] |= 128 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
        for (var i = 0; i < m.length; i += 16) {
          var aa = a, bb = b, cc = c, dd = d;
          a = FF(a, b, c, d, m[i + 0], 7, -680876936);
          d = FF(d, a, b, c, m[i + 1], 12, -389564586);
          c = FF(c, d, a, b, m[i + 2], 17, 606105819);
          b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
          a = FF(a, b, c, d, m[i + 4], 7, -176418897);
          d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
          c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
          b = FF(b, c, d, a, m[i + 7], 22, -45705983);
          a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
          d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
          c = FF(c, d, a, b, m[i + 10], 17, -42063);
          b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
          a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
          d = FF(d, a, b, c, m[i + 13], 12, -40341101);
          c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
          b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
          a = GG(a, b, c, d, m[i + 1], 5, -165796510);
          d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
          c = GG(c, d, a, b, m[i + 11], 14, 643717713);
          b = GG(b, c, d, a, m[i + 0], 20, -373897302);
          a = GG(a, b, c, d, m[i + 5], 5, -701558691);
          d = GG(d, a, b, c, m[i + 10], 9, 38016083);
          c = GG(c, d, a, b, m[i + 15], 14, -660478335);
          b = GG(b, c, d, a, m[i + 4], 20, -405537848);
          a = GG(a, b, c, d, m[i + 9], 5, 568446438);
          d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
          c = GG(c, d, a, b, m[i + 3], 14, -187363961);
          b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
          a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
          d = GG(d, a, b, c, m[i + 2], 9, -51403784);
          c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
          b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
          a = HH(a, b, c, d, m[i + 5], 4, -378558);
          d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
          c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
          b = HH(b, c, d, a, m[i + 14], 23, -35309556);
          a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
          d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
          c = HH(c, d, a, b, m[i + 7], 16, -155497632);
          b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
          a = HH(a, b, c, d, m[i + 13], 4, 681279174);
          d = HH(d, a, b, c, m[i + 0], 11, -358537222);
          c = HH(c, d, a, b, m[i + 3], 16, -722521979);
          b = HH(b, c, d, a, m[i + 6], 23, 76029189);
          a = HH(a, b, c, d, m[i + 9], 4, -640364487);
          d = HH(d, a, b, c, m[i + 12], 11, -421815835);
          c = HH(c, d, a, b, m[i + 15], 16, 530742520);
          b = HH(b, c, d, a, m[i + 2], 23, -995338651);
          a = II(a, b, c, d, m[i + 0], 6, -198630844);
          d = II(d, a, b, c, m[i + 7], 10, 1126891415);
          c = II(c, d, a, b, m[i + 14], 15, -1416354905);
          b = II(b, c, d, a, m[i + 5], 21, -57434055);
          a = II(a, b, c, d, m[i + 12], 6, 1700485571);
          d = II(d, a, b, c, m[i + 3], 10, -1894986606);
          c = II(c, d, a, b, m[i + 10], 15, -1051523);
          b = II(b, c, d, a, m[i + 1], 21, -2054922799);
          a = II(a, b, c, d, m[i + 8], 6, 1873313359);
          d = II(d, a, b, c, m[i + 15], 10, -30611744);
          c = II(c, d, a, b, m[i + 6], 15, -1560198380);
          b = II(b, c, d, a, m[i + 13], 21, 1309151649);
          a = II(a, b, c, d, m[i + 4], 6, -145523070);
          d = II(d, a, b, c, m[i + 11], 10, -1120210379);
          c = II(c, d, a, b, m[i + 2], 15, 718787259);
          b = II(b, c, d, a, m[i + 9], 21, -343485551);
          a = a + aa >>> 0;
          b = b + bb >>> 0;
          c = c + cc >>> 0;
          d = d + dd >>> 0;
        }
        return crypt.endian([a, b, c, d]);
      };
      md5._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md5._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md5._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md5._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md5._blocksize = 16;
      md5._digestsize = 16;
      module.exports = function(message, options) {
        if (message === void 0 || message === null)
          throw new Error("Illegal argument " + message);
        var digestbytes = crypt.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
    })();
  }
});

// node_modules/sha3/sponge/permute/copy/index.js
var require_copy = __commonJS({
  "node_modules/sha3/sponge/permute/copy/index.js"(exports, module) {
    "use strict";
    var copy = function copy2(I, i) {
      return function(O, o) {
        var oi = o * 2;
        var ii = i * 2;
        O[oi] = I[ii];
        O[oi + 1] = I[ii + 1];
      };
    };
    module.exports = copy;
  }
});

// node_modules/sha3/sponge/permute/chi/index.js
var require_chi = __commonJS({
  "node_modules/sha3/sponge/permute/chi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var chi = function chi2(_ref) {
      var A = _ref.A, C = _ref.C;
      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }
        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };
    var _default = chi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/round-constants/index.js
var require_round_constants = __commonJS({
  "node_modules/sha3/sponge/permute/iota/round-constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/index.js
var require_iota = __commonJS({
  "node_modules/sha3/sponge/permute/iota/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _roundConstants = _interopRequireDefault(require_round_constants());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var iota = function iota2(_ref) {
      var A = _ref.A, roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };
    var _default = iota;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js
var require_pi_shuffles = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js
var require_rho_offsets = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/index.js
var require_rho_pi = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _piShuffles = _interopRequireDefault(require_pi_shuffles());
    var _rhoOffsets = _interopRequireDefault(require_rho_offsets());
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var rhoPi = function rhoPi2(_ref) {
      var A = _ref.A, C = _ref.C, W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;
      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };
    var _default = rhoPi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/theta/index.js
var require_theta = __commonJS({
  "node_modules/sha3/sponge/permute/theta/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var theta = function theta2(_ref) {
      var A = _ref.A, C = _ref.C, D = _ref.D, W = _ref.W;
      var H = 0;
      var L = 0;
      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }
      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];
        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };
    var _default = theta;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/index.js
var require_permute = __commonJS({
  "node_modules/sha3/sponge/permute/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _chi = _interopRequireDefault(require_chi());
    var _iota = _interopRequireDefault(require_iota());
    var _rhoPi = _interopRequireDefault(require_rho_pi());
    var _theta = _interopRequireDefault(require_theta());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var permute = function permute2() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function(A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({ A, C, D, W });
          (0, _rhoPi["default"])({ A, C, W });
          (0, _chi["default"])({ A, C });
          (0, _iota["default"])({ A, roundIndex });
        }
        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };
    var _default = permute;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/index.js
var require_sponge = __commonJS({
  "node_modules/sha3/sponge/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _buffer = require_buffer();
    var _permute = _interopRequireDefault(require_permute());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var xorWords = function xorWords2(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }
      return O;
    };
    var readWords = function readWords2(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }
      return O;
    };
    var Sponge = function Sponge2(_ref) {
      var _this = this;
      var capacity = _ref.capacity, padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);
      var queue = _buffer.Buffer.allocUnsafe(queueSize);
      this.absorb = function(buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;
          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }
        return _this;
      };
      this.squeeze = function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var output = { buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize), padding: options.padding || padding, queue: _buffer.Buffer.allocUnsafe(queue.length), state: new Uint32Array(state.length) };
        queue.copy(output.queue);
        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }
        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);
        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }
        return output.buffer;
      };
      this.reset = function() {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };
      return this;
    };
    var _default = Sponge;
    exports["default"] = _default;
  }
});

// node_modules/sha3/index.js
var require_sha3 = __commonJS({
  "node_modules/sha3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = require_buffer();
    var _sponge = _interopRequireDefault(require_sponge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var createHash = function createHash2(_ref) {
      var allowedSizes = _ref.allowedSizes, defaultSize = _ref.defaultSize, padding = _ref.padding;
      return function Hash() {
        var _this = this;
        var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSize;
        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }
        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }
        var sponge = new _sponge["default"]({ capacity: size });
        this.update = function(input) {
          var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }
          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }
          throw new TypeError("Not a string or buffer");
        };
        this.digest = function() {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? { format: formatOrOptions } : formatOrOptions;
          var buffer = sponge.squeeze({ buffer: options.buffer, padding: options.padding || padding });
          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }
          return buffer;
        };
        this.reset = function() {
          sponge.reset();
          return _this;
        };
        return this;
      };
    };
    var Keccak = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 1 });
    exports.Keccak = Keccak;
    var SHA3 = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 6 });
    exports.SHA3 = SHA3;
    var SHAKE = createHash({ allowedSizes: [128, 256], defaultSize: 256, padding: 31 });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA3.SHA3Hash = SHA3Hash;
    var _default = SHA3;
    exports["default"] = _default;
  }
});

// node_modules/js-crypto-hash/dist/hash.js
var require_hash2 = __commonJS({
  "node_modules/js-crypto-hash/dist/hash.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compute = void 0;
    var util = __importStar(require_dist());
    var params_1 = __importDefault(require_params2());
    var md5_1 = __importDefault(require_md5());
    var sha3_1 = require_sha3();
    var jsHash = __importStar(require_hash());
    var compute = function(msg, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, msgHash, errMsg, native, e_1, e_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              env = util.getCrypto();
              native = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 5, , 6]);
              if (!(env.name === "webCrypto" && typeof env.crypto.digest === "function"))
                return [3, 3];
              return [4, env.crypto.digest(hash, msg)];
            case 2:
              msgHash = _a.sent();
              return [3, 4];
            case 3:
              if (env.name === "nodeCrypto") {
                msgHash = nodedigest(hash, msg, env.crypto);
              } else
                native = false;
              _a.label = 4;
            case 4:
              return [3, 6];
            case 5:
              e_1 = _a.sent();
              if (e_1 instanceof Error) {
                errMsg = e_1.message;
              }
              native = false;
              return [3, 6];
            case 6:
              if (!!native)
                return [3, 10];
              _a.label = 7;
            case 7:
              _a.trys.push([7, 9, , 10]);
              return [4, purejs(hash, msg)];
            case 8:
              msgHash = _a.sent();
              return [3, 10];
            case 9:
              e_2 = _a.sent();
              if (e_2 instanceof Error) {
                errMsg = "".concat(typeof errMsg === "undefined" ? "" : errMsg, " => ").concat(e_2.message);
                throw new Error("UnsupportedEnvironment: ".concat(errMsg));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 10];
            case 10:
              return [2, new Uint8Array(msgHash)];
          }
        });
      });
    };
    exports.compute = compute;
    var nodedigest = function(hash, msg, nodeCrypto) {
      var alg = params_1.default.hashes[hash].nodeName;
      var hashFunc = nodeCrypto.createHash(alg);
      hashFunc.update(msg);
      return hashFunc.digest();
    };
    var purejs = function(hash, msg) {
      return __awaiter(void 0, void 0, void 0, function() {
        var h, sha3Len, sha3obj, Buffer_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(hash === "MD5"))
                return [3, 1];
              h = (0, md5_1.default)(Array.from(msg), { asBytes: true });
              return [3, 4];
            case 1:
              if (!(["SHA3-512", "SHA3-384", "SHA3-256", "SHA3-224"].indexOf(hash) >= 0))
                return [3, 3];
              sha3Len = params_1.default.hashes[hash].hashSize * 8;
              sha3obj = new sha3_1.SHA3(sha3Len);
              return [4, Promise.resolve().then(function() {
                return __importStar(require_buffer());
              })];
            case 2:
              Buffer_1 = _a.sent().Buffer;
              sha3obj.update(Buffer_1.from(msg));
              h = sha3obj.digest("binary");
              return [3, 4];
            case 3:
              h = jsHash[params_1.default.hashes[hash].nodeName]().update(msg).digest();
              _a.label = 4;
            case 4:
              return [2, new Uint8Array(h)];
          }
        });
      });
    };
  }
});

// node_modules/js-crypto-hash/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/js-crypto-hash/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compute = void 0;
    var hash = __importStar(require_hash2());
    exports.compute = hash.compute;
    exports.default = { compute: exports.compute };
  }
});

// node_modules/js-crypto-hmac/dist/params.js
var require_params3 = __commonJS({
  "node_modules/js-crypto-hmac/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { nodeName: "sha3-512", hashSize: 64, blockSize: 72 },
        "SHA3-384": { nodeName: "sha3-384", hashSize: 48, blockSize: 104 },
        "SHA3-256": { nodeName: "sha3-256", hashSize: 32, blockSize: 136 },
        "SHA3-224": { nodeName: "sha3-224", hashSize: 28, blockSize: 144 },
        "SHA-256": { nodeName: "sha256", hashSize: 32, blockSize: 64 },
        "SHA-384": { nodeName: "sha384", hashSize: 48, blockSize: 128 },
        "SHA-512": { nodeName: "sha512", hashSize: 64, blockSize: 128 },
        "SHA-1": { nodeName: "sha1", hashSize: 20, blockSize: 64 },
        "MD5": { nodeName: "md5", hashSize: 16, blockSize: 64 }
      }
    };
    exports.default = params;
  }
});

// node_modules/js-crypto-hmac/dist/hmac.js
var require_hmac = __commonJS({
  "node_modules/js-crypto-hmac/dist/hmac.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.compute = void 0;
    var params_1 = __importDefault(require_params3());
    var util = __importStar(require_dist());
    var js_crypto_hash_1 = __importDefault(require_dist4());
    var compute = function(key, data, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, msgKeyedHash, errMsg, native, keyObj, f, e_1, e_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              env = util.getCrypto();
              native = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 6, , 7]);
              if (!(env.name === "webCrypto" && typeof env.crypto.importKey === "function" && typeof env.crypto.sign === "function"))
                return [3, 4];
              return [4, env.crypto.importKey("raw", key, {
                name: "HMAC",
                hash: { name: hash }
              }, false, ["sign", "verify"])];
            case 2:
              keyObj = _a.sent();
              return [4, env.crypto.sign({ name: "HMAC", hash: { name: hash } }, keyObj, data)];
            case 3:
              msgKeyedHash = _a.sent();
              return [3, 5];
            case 4:
              if (env.name === "nodeCrypto") {
                f = env.crypto.createHmac(params_1.default.hashes[hash].nodeName, key);
                msgKeyedHash = f.update(data).digest();
              } else
                native = false;
              _a.label = 5;
            case 5:
              return [3, 7];
            case 6:
              e_1 = _a.sent();
              if (e_1 instanceof Error) {
                errMsg = e_1.message;
              }
              native = false;
              return [3, 7];
            case 7:
              if (!!native)
                return [3, 11];
              _a.label = 8;
            case 8:
              _a.trys.push([8, 10, , 11]);
              return [4, purejs(key, data, hash)];
            case 9:
              msgKeyedHash = _a.sent();
              return [3, 11];
            case 10:
              e_2 = _a.sent();
              if (e_2 instanceof Error) {
                errMsg = "".concat(errMsg, " => ").concat(e_2.message);
                throw new Error("UnsupportedEnvironments: ".concat(errMsg));
              } else {
                throw new Error("UnsupportedEnvironments");
              }
              return [3, 11];
            case 11:
              return [2, new Uint8Array(msgKeyedHash)];
          }
        });
      });
    };
    exports.compute = compute;
    var purejs = function(key, data, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var B, L, K, KxorIpad, KxorOpad, inner, hashedInner, outer;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              B = params_1.default.hashes[hash].blockSize;
              L = params_1.default.hashes[hash].hashSize;
              if (!(key.length > B))
                return [3, 2];
              return [4, js_crypto_hash_1.default.compute(key, hash)];
            case 1:
              key = _a.sent();
              _a.label = 2;
            case 2:
              K = new Uint8Array(B);
              K.set(key);
              KxorIpad = K.map(function(k) {
                return 255 & (54 ^ k);
              });
              KxorOpad = K.map(function(k) {
                return 255 & (92 ^ k);
              });
              inner = new Uint8Array(B + data.length);
              inner.set(KxorIpad);
              inner.set(data, B);
              return [4, js_crypto_hash_1.default.compute(inner, hash)];
            case 3:
              hashedInner = _a.sent();
              outer = new Uint8Array(B + L);
              outer.set(KxorOpad);
              outer.set(hashedInner, B);
              return [2, js_crypto_hash_1.default.compute(outer, hash)];
          }
        });
      });
    };
    var verify = function(key, data, mac, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var newMac;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, exports.compute)(key, data, hash)];
            case 1:
              newMac = _a.sent();
              return [2, mac.toString() === newMac.toString()];
          }
        });
      });
    };
    exports.verify = verify;
  }
});

// node_modules/js-crypto-hmac/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/js-crypto-hmac/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.compute = void 0;
    var hmac = __importStar(require_hmac());
    exports.compute = hmac.compute;
    exports.verify = hmac.verify;
    exports.default = { compute: exports.compute, verify: exports.verify };
  }
});

// node_modules/js-crypto-pbkdf/dist/params.js
var require_params4 = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { hashSize: 64 },
        "SHA3-384": { hashSize: 48 },
        "SHA3-256": { hashSize: 32 },
        "SHA3-224": { hashSize: 28 },
        "SHA-256": { hashSize: 32 },
        "SHA-384": { hashSize: 48 },
        "SHA-512": { hashSize: 64 },
        "SHA-1": { hashSize: 20 },
        "MD5": { hashSize: 16 }
        // SHOULD NOT USE
      }
    };
    exports.default = params;
  }
});

// node_modules/js-crypto-pbkdf/dist/pbkdf.js
var require_pbkdf = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/pbkdf.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf1 = exports.pbkdf2 = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_hash_1 = __importDefault(require_dist4());
    var js_crypto_hmac_1 = __importDefault(require_dist5());
    var params_1 = __importDefault(require_params4());
    var pbkdf2 = function(p, s, c, dkLen, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var uintP, hLen, l, r, funcF, Tis, DK, i, TisResolved;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (c <= 0)
                throw new Error("InvalidIterationCount");
              if (dkLen <= 0)
                throw new Error("InvalidDerivedKeyLength");
              uintP = typeof p === "string" ? js_encoding_utils_1.default.encoder.stringToArrayBuffer(p) : p;
              hLen = params_1.default.hashes[hash].hashSize;
              if (dkLen > (Math.pow(2, 32) - 1) * hLen)
                throw new Error("DerivedKeyTooLong");
              l = Math.ceil(dkLen / hLen);
              r = dkLen - (l - 1) * hLen;
              funcF = function(i2) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var seed, u, outputF, j;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        seed = new Uint8Array(s.length + 4);
                        seed.set(s);
                        seed.set(nwbo(i2 + 1, 4), s.length);
                        return [4, js_crypto_hmac_1.default.compute(uintP, seed, hash)];
                      case 1:
                        u = _a2.sent();
                        outputF = new Uint8Array(u);
                        j = 1;
                        _a2.label = 2;
                      case 2:
                        if (!(j < c))
                          return [3, 5];
                        return [4, js_crypto_hmac_1.default.compute(uintP, u, hash)];
                      case 3:
                        u = _a2.sent();
                        outputF = u.map(function(elem, idx) {
                          return elem ^ outputF[idx];
                        });
                        _a2.label = 4;
                      case 4:
                        j++;
                        return [3, 2];
                      case 5:
                        return [2, { index: i2, value: outputF }];
                    }
                  });
                });
              };
              Tis = [];
              DK = new Uint8Array(dkLen);
              for (i = 0; i < l; i++)
                Tis.push(funcF(i));
              return [4, Promise.all(Tis)];
            case 1:
              TisResolved = _a.sent();
              TisResolved.forEach(function(elem) {
                if (elem.index !== l - 1)
                  DK.set(elem.value, elem.index * hLen);
                else
                  DK.set(elem.value.slice(0, r), elem.index * hLen);
              });
              return [2, DK];
          }
        });
      });
    };
    exports.pbkdf2 = pbkdf2;
    var nwbo = function(num, len) {
      var arr = new Uint8Array(len);
      for (var i = 0; i < len; i++)
        arr[i] = num >> (len - i - 1) * 8;
      return arr;
    };
    var pbkdf1 = function(p, s, c, dkLen, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var seed, i;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (c <= 0)
                throw new Error("InvalidIterationCount");
              if (dkLen <= 0)
                throw new Error("InvalidDerivedKeyLength");
              if (typeof p === "string")
                p = js_encoding_utils_1.default.encoder.stringToArrayBuffer(p);
              if (dkLen > params_1.default.hashes[hash].hashSize)
                throw new Error("DerivedKeyTooLong");
              seed = new Uint8Array(p.length + s.length);
              seed.set(p);
              seed.set(s, p.length);
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < c))
                return [3, 4];
              return [4, js_crypto_hash_1.default.compute(seed, hash)];
            case 2:
              seed = _a.sent();
              _a.label = 3;
            case 3:
              i++;
              return [3, 1];
            case 4:
              return [2, seed.slice(0, dkLen)];
          }
        });
      });
    };
    exports.pbkdf1 = pbkdf1;
  }
});

// node_modules/js-crypto-pbkdf/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf1 = exports.pbkdf2 = void 0;
    var pbkdf = __importStar(require_pbkdf());
    exports.pbkdf2 = pbkdf.pbkdf2;
    exports.pbkdf1 = pbkdf.pbkdf1;
    exports.default = { pbkdf2: exports.pbkdf2, pbkdf1: exports.pbkdf1 };
  }
});

// node_modules/js-crypto-key-utils/dist/rfc8018.js
var require_rfc8018 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/rfc8018.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptEncryptedPrivateKeyInfo = exports.encryptEncryptedPrivateKeyInfo = void 0;
    var params = __importStar(require_params());
    var asn1def_1 = require_asn1def();
    var des_js_1 = __importDefault(require_des());
    var BufferMod = __importStar(require_buffer());
    var asn1_js_1 = __importDefault(require_asn1());
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_pbkdf_1 = __importDefault(require_dist6());
    var js_crypto_aes_1 = __importDefault(require_dist2());
    var js_crypto_random_1 = __importDefault(require_dist3());
    var Buffer2 = BufferMod.Buffer;
    var BN = asn1_js_1.default.bignum;
    var encryptEncryptedPrivateKeyInfo = function(binKey, options) {
      if (options === void 0) {
        options = { passphrase: "" };
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var kdfAlgorithm, encryptedPBES2, encryptedPBES1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (typeof options.algorithm === "undefined")
                options.algorithm = "pbes2";
              if (typeof options.iterationCount === "undefined")
                options.iterationCount = 2048;
              if (!(options.algorithm === "pbes2"))
                return [3, 2];
              if (typeof options.cipher === "undefined")
                options.cipher = "aes256-cbc";
              if (typeof options.prf === "undefined")
                options.prf = "hmacWithSHA256";
              kdfAlgorithm = "pbkdf2";
              return [4, encryptPBES2(binKey, options.passphrase, kdfAlgorithm, options.prf, options.iterationCount, options.cipher)];
            case 1:
              encryptedPBES2 = _a.sent();
              return [2, encodePBES2(encryptedPBES2)];
            case 2:
              return [4, encryptPBES1(binKey, options.passphrase, options.algorithm, options.iterationCount)];
            case 3:
              encryptedPBES1 = _a.sent();
              encryptedPBES1.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[encryptedPBES1.encryptionAlgorithm.algorithm].oid;
              encryptedPBES1.encryptionAlgorithm.parameters = asn1def_1.PBEParameter.encode(encryptedPBES1.encryptionAlgorithm.parameters, "der");
              return [2, asn1def_1.EncryptedPrivateKeyInfo.encode(encryptedPBES1, "der")];
          }
        });
      });
    };
    exports.encryptEncryptedPrivateKeyInfo = encryptEncryptedPrivateKeyInfo;
    var decryptEncryptedPrivateKeyInfo = function(epki, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var decoded;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              decoded = {};
              decoded.encryptionAlgorithm = {
                algorithm: params.getAlgorithmFromOidStrict(epki.encryptionAlgorithm.algorithm, params.passwordBasedEncryptionSchemes)
              };
              if (decoded.encryptionAlgorithm.algorithm === "pbes2") {
                decoded.encryptionAlgorithm.parameters = decodePBES2(epki.encryptionAlgorithm.parameters);
              } else {
                decoded.encryptionAlgorithm.parameters = asn1def_1.PBEParameter.decode(epki.encryptionAlgorithm.parameters, "der");
              }
              decoded.encryptedData = epki.encryptedData;
              if (!(decoded.encryptionAlgorithm.algorithm === "pbes2"))
                return [3, 2];
              return [4, decryptPBES2(decoded, passphrase)];
            case 1:
              return [2, _a.sent()];
            case 2:
              return [4, decryptPBES1(decoded, passphrase)];
            case 3:
              return [2, _a.sent()];
          }
        });
      });
    };
    exports.decryptEncryptedPrivateKeyInfo = decryptEncryptedPrivateKeyInfo;
    var encodePBES2 = function(decoded) {
      var epki = { encryptionAlgorithm: {} };
      epki.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].oid;
      var kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;
      if (kdf.algorithm === "pbkdf2") {
        kdf.parameters.prf.algorithm = params.pbkdf2Prfs[kdf.parameters.prf.algorithm].oid;
        kdf.parameters = asn1def_1.PBKDF2Params.encode(kdf.parameters, "der");
      } else
        throw new Error("UnsupportedKDF");
      kdf.algorithm = params.keyDerivationFunctions[kdf.algorithm].oid;
      var eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;
      if (Object.keys(asn1def_1.PBES2ESParams).indexOf(eS.algorithm) >= 0) {
        eS.parameters = asn1def_1.PBES2ESParams[eS.algorithm].encode(eS.parameters, "der");
      } else
        throw new Error("UnsupportedCipher");
      eS.algorithm = params.encryptionSchemes[eS.algorithm].oid;
      epki.encryptionAlgorithm.parameters = asn1def_1.PBES2Params.encode({ keyDerivationFunc: kdf, encryptionScheme: eS }, "der");
      epki.encryptedData = decoded.encryptedData;
      return asn1def_1.EncryptedPrivateKeyInfo.encode(epki, "der");
    };
    var decodePBES2 = function(rawParams) {
      var pbes2Params = asn1def_1.PBES2Params.decode(rawParams, "der");
      var kdfAlgorithm = params.getAlgorithmFromOidStrict(pbes2Params.keyDerivationFunc.algorithm, params.keyDerivationFunctions);
      var iterationCount;
      var salt;
      var prf;
      if (kdfAlgorithm === "pbkdf2") {
        var pbkdf2Params = asn1def_1.PBKDF2Params.decode(pbes2Params.keyDerivationFunc.parameters, "der");
        prf = {
          algorithm: params.getAlgorithmFromOidStrict(pbkdf2Params.prf.algorithm, params.pbkdf2Prfs),
          parameters: pbkdf2Params.prf.parameters
        };
        iterationCount = pbkdf2Params.iterationCount;
        salt = { type: pbkdf2Params.salt.type, value: pbkdf2Params.salt.value };
      } else
        throw new Error("UnsupportedKDF");
      var encryptionScheme = params.getAlgorithmFromOidStrict(pbes2Params.encryptionScheme.algorithm, params.encryptionSchemes);
      var encryptionParams;
      if (Object.keys(asn1def_1.PBES2ESParams).indexOf(encryptionScheme) >= 0) {
        encryptionParams = asn1def_1.PBES2ESParams[encryptionScheme].decode(pbes2Params.encryptionScheme.parameters, "der");
      } else
        throw new Error("UnsupportedCipher");
      return {
        keyDerivationFunc: {
          algorithm: kdfAlgorithm,
          parameters: { salt, iterationCount, prf }
        },
        encryptionScheme: {
          algorithm: encryptionScheme,
          parameters: encryptionParams
        }
      };
    };
    var encryptPBES2 = function(binKey, passphrase, kdfAlgorithm, prf, iterationCount, cipher) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, keyLength, key, iv, encryptedData, _a, _b, CBC, ct, _c, _d;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              return [4, js_crypto_random_1.default.getRandomBytes(params.keyDerivationFunctions[kdfAlgorithm].defaultSaltLen)];
            case 1:
              salt = _e.sent();
              keyLength = params.encryptionSchemes[cipher].keyLength;
              if (!(kdfAlgorithm === "pbkdf2"))
                return [3, 3];
              return [4, js_crypto_pbkdf_1.default.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash)];
            case 2:
              key = _e.sent();
              return [3, 4];
            case 3:
              throw new Error("UnsupportedKDF");
            case 4:
              if (!(cipher === "des-ede3-cbc"))
                return [3, 6];
              _b = (_a = Buffer2).from;
              return [4, js_crypto_random_1.default.getRandomBytes(params.encryptionSchemes[cipher].ivLength)];
            case 5:
              iv = _b.apply(_a, [_e.sent()]);
              CBC = des_js_1.default.CBC.instantiate(des_js_1.default.EDE);
              ct = CBC.create({ type: "encrypt", key: Buffer2.from(key), iv });
              encryptedData = Buffer2.from(ct.update(binKey).concat(ct.final()));
              return [3, 10];
            case 6:
              if (!(cipher === "aes128-cbc" || cipher === "aes192-cbc" || cipher === "aes256-cbc"))
                return [3, 9];
              return [4, js_crypto_random_1.default.getRandomBytes(params.encryptionSchemes[cipher].ivLength)];
            case 7:
              iv = _e.sent();
              _d = (_c = Buffer2).from;
              return [4, js_crypto_aes_1.default.encrypt(new Uint8Array(binKey), key, { name: "AES-CBC", iv })];
            case 8:
              encryptedData = _d.apply(_c, [_e.sent()]);
              iv = Buffer2.from(iv);
              return [3, 10];
            case 9:
              throw new Error("UnsupportedCipher");
            case 10:
              return [2, {
                encryptedData,
                encryptionAlgorithm: {
                  algorithm: "pbes2",
                  parameters: {
                    keyDerivationFunc: {
                      algorithm: kdfAlgorithm,
                      parameters: {
                        salt: { type: "specified", value: Buffer2.from(salt) },
                        iterationCount: new BN(iterationCount),
                        prf: { algorithm: prf, parameters: Buffer2.from([5, 0]) }
                      }
                    },
                    encryptionScheme: { algorithm: cipher, parameters: iv }
                  }
                }
              }];
          }
        });
      });
    };
    var decryptPBES2 = function(decoded, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var kdf, eS, keyLength, key, pBuffer, salt, iterationCount, prf, out, iv, CBC, pt, iv, _a, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;
              eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;
              keyLength = params.encryptionSchemes[eS.algorithm].keyLength;
              if (!(kdf.algorithm === "pbkdf2"))
                return [3, 2];
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              if (kdf.parameters.salt.type !== "specified")
                throw new Error("UnsupportedSaltSource");
              salt = new Uint8Array(kdf.parameters.salt.value);
              iterationCount = kdf.parameters.iterationCount.toNumber();
              prf = kdf.parameters.prf.algorithm;
              return [4, js_crypto_pbkdf_1.default.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash)];
            case 1:
              key = _c.sent();
              return [3, 3];
            case 2:
              throw new Error("UnsupportedKDF");
            case 3:
              if (!(eS.algorithm === "des-ede3-cbc"))
                return [3, 4];
              iv = eS.parameters;
              CBC = des_js_1.default.CBC.instantiate(des_js_1.default.EDE);
              pt = CBC.create({ type: "decrypt", key, iv });
              out = Buffer2.from(pt.update(decoded.encryptedData).concat(pt.final()));
              return [3, 7];
            case 4:
              if (!(eS.algorithm === "aes128-cbc" || eS.algorithm === "aes192-cbc" || eS.algorithm === "aes256-cbc"))
                return [3, 6];
              iv = new Uint8Array(eS.parameters);
              _b = (_a = Buffer2).from;
              return [4, js_crypto_aes_1.default.decrypt(new Uint8Array(decoded.encryptedData), key, { name: "AES-CBC", iv })];
            case 5:
              out = _b.apply(_a, [_c.sent()]);
              return [3, 7];
            case 6:
              throw new Error("UnsupportedEncryptionAlgorithm");
            case 7:
              return [2, asn1def_1.OneAsymmetricKey.decode(out, "der")];
          }
        });
      });
    };
    var encryptPBES1 = function(binKey, passphrase, algorithm, iterationCount) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, hash, keyIv, key, iv, encrypt, out, CBC, ct;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              return [4, js_crypto_random_1.default.getRandomBytes(8)];
            case 1:
              salt = _a.sent();
              hash = params.passwordBasedEncryptionSchemes[algorithm].hash;
              return [4, js_crypto_pbkdf_1.default.pbkdf1(pBuffer, salt, iterationCount, 16, hash)];
            case 2:
              keyIv = _a.sent();
              key = keyIv.slice(0, 8);
              iv = keyIv.slice(8, 16);
              encrypt = params.passwordBasedEncryptionSchemes[algorithm].encrypt;
              if (encrypt === "DES-CBC") {
                CBC = des_js_1.default.CBC.instantiate(des_js_1.default.DES);
                ct = CBC.create({ type: "encrypt", key, iv });
                out = Buffer2.from(ct.update(binKey).concat(ct.final()));
              } else
                throw new Error("UnsupportedEncryptionAlgorithm");
              return [2, {
                encryptionAlgorithm: {
                  algorithm,
                  parameters: {
                    salt: Buffer2.from(salt),
                    iterationCount: new BN(iterationCount)
                  }
                },
                encryptedData: out
              }];
          }
        });
      });
    };
    var decryptPBES1 = function(decoded, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, hash, iterationCount, keyIv, key, iv, encrypt, out, CBC, ct;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              salt = new Uint8Array(decoded.encryptionAlgorithm.parameters.salt);
              hash = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].hash;
              iterationCount = decoded.encryptionAlgorithm.parameters.iterationCount.toNumber();
              return [4, js_crypto_pbkdf_1.default.pbkdf1(pBuffer, salt, iterationCount, 16, hash)];
            case 1:
              keyIv = _a.sent();
              key = keyIv.slice(0, 8);
              iv = keyIv.slice(8, 16);
              encrypt = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].encrypt;
              if (encrypt === "DES-CBC") {
                CBC = des_js_1.default.CBC.instantiate(des_js_1.default.DES);
                ct = CBC.create({ type: "decrypt", key, iv });
                out = Buffer2.from(ct.update(decoded.encryptedData).concat(ct.final()));
              } else
                throw new Error("UnsupportedEncryptionAlgorithm");
              return [2, asn1def_1.OneAsymmetricKey.decode(out, "der")];
          }
        });
      });
    };
  }
});

// node_modules/js-crypto-key-utils/dist/asn1enc.js
var require_asn1enc = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1enc.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var asn1ec = __importStar(require_asn1ec());
    var asn1rsa = __importStar(require_asn1rsa());
    var params_1 = require_params();
    var js_encoding_utils_1 = __importDefault(require_src());
    var BufferMod = __importStar(require_buffer());
    var asn1def_1 = require_asn1def();
    var rfc8018_1 = require_rfc8018();
    var util_1 = require_util();
    var Buffer2 = BufferMod.Buffer;
    var fromJwk = function(jwkey, format, _a) {
      var outputPublic = _a.outputPublic, _b = _a.compact, compact = _b === void 0 ? false : _b, encOptions = _a.encOptions;
      return __awaiter(void 0, void 0, void 0, function() {
        var orgType, type, decoded, binKey;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              orgType = (0, util_1.getJwkType)(jwkey);
              type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
              if (jwkey.kty === "EC") {
                decoded = asn1ec.fromJWK(jwkey, type, compact);
              } else if (jwkey.kty === "RSA") {
                decoded = asn1rsa.fromJwk(jwkey, type);
              }
              if (!(type === "public"))
                return [3, 1];
              binKey = asn1def_1.SubjectPublicKeyInfo.encode(decoded, "der");
              return [3, 3];
            case 1:
              binKey = asn1def_1.OneAsymmetricKey.encode(decoded, "der");
              if (!(typeof encOptions !== "undefined" && typeof encOptions.passphrase !== "undefined" && encOptions.passphrase.length > 0))
                return [3, 3];
              return [4, (0, rfc8018_1.encryptEncryptedPrivateKeyInfo)(binKey, encOptions)];
            case 2:
              binKey = _c.sent();
              type = "encryptedPrivate";
              _c.label = 3;
            case 3:
              binKey = new Uint8Array(binKey);
              return [2, format === "pem" ? js_encoding_utils_1.default.formatter.binToPem(binKey, type) : binKey];
          }
        });
      });
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(key, format, _a) {
      var outputPublic = _a.outputPublic, passphrase = _a.passphrase;
      return __awaiter(void 0, void 0, void 0, function() {
        var binKey, decoded, type, keyTypes;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              binKey = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(key) : key;
              try {
                decoded = asn1def_1.KeyStructure.decode(Buffer2.from(binKey), "der");
              } catch (e) {
                throw new Error("FailedToDecodeKey");
              }
              if (!(decoded.type === "subjectPublicKeyInfo"))
                return [3, 1];
              type = "public";
              decoded = decoded.value;
              return [3, 4];
            case 1:
              type = typeof outputPublic === "boolean" && outputPublic ? "public" : "private";
              if (!(decoded.type === "encryptedPrivateKeyInfo"))
                return [3, 3];
              return [4, (0, rfc8018_1.decryptEncryptedPrivateKeyInfo)(decoded.value, passphrase)];
            case 2:
              decoded = _b.sent();
              return [3, 4];
            case 3:
              if (decoded.type === "oneAsymmetricKey")
                decoded = decoded.value;
              else
                throw new Error("UnsupportedKeyStructure");
              _b.label = 4;
            case 4:
              keyTypes = (0, params_1.getAlgorithmFromOid)(type === "public" ? decoded.algorithm.algorithm : decoded.privateKeyAlgorithm.algorithm, params_1.publicKeyAlgorithms);
              if (keyTypes.length < 1)
                throw new Error("UnsupportedKey");
              if (keyTypes[0] === "EC") {
                return [2, asn1ec.toJWK(decoded, type)];
              } else if (keyTypes[0] === "RSA") {
                return [2, asn1rsa.toJwk(decoded, type)];
              } else
                throw new Error("InvalidKeyType");
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.toJwk = toJwk;
  }
});

// node_modules/js-crypto-key-utils/dist/converter.js
var require_converter = __commonJS({
  "node_modules/js-crypto-key-utils/dist/converter.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwkFrom = exports.fromJwkTo = void 0;
    var asn1enc = __importStar(require_asn1enc());
    var octenc = __importStar(require_octenc());
    var fromJwkTo = function(output, jwkey, options) {
      if (output === void 0) {
        output = "pem";
      }
      if (options === void 0) {
        options = {};
      }
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (jwkey.kty !== "EC" && jwkey.kty !== "RSA")
                throw new Error("UnsupportedKeyType");
              if (jwkey.kty === "EC" && typeof options.compact === "undefined")
                options.compact = false;
              if (output === "oct" && options.output !== "string")
                options.output = "binary";
              if (typeof options.encryptParams === "undefined")
                options.encryptParams = { passphrase: "" };
              if ((output === "der" || output === "pem") && typeof options.encryptParams.passphrase === "undefined")
                options.encryptParams.passphrase = "";
              if (!(output === "der" || output === "pem"))
                return [3, 2];
              return [4, asn1enc.fromJwk(jwkey, output, { outputPublic: options.outputPublic, compact: options.compact, encOptions: options.encryptParams })];
            case 1:
              return [2, _a.sent()];
            case 2:
              if (output === "oct" && jwkey.kty === "EC") {
                return [2, octenc.fromJwk(jwkey, { outputPublic: options.outputPublic, outputFormat: options.output, compact: options.compact })];
              } else
                throw new Error("UnsupportedConversion");
              _a.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.fromJwkTo = fromJwkTo;
    var toJwkFrom = function(input, key, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (input === "oct" && !options.namedCurve)
                throw new Error("InappropriateOptions");
              if ((input === "der" || input === "pem") && typeof options.passphrase === "undefined")
                options.passphrase = "";
              if (!(input === "der" || input === "pem"))
                return [3, 2];
              return [4, asn1enc.toJwk(key, input, { outputPublic: options.outputPublic, passphrase: options.passphrase })];
            case 1:
              return [2, _a.sent()];
            case 2:
              if (input === "oct") {
                return [2, octenc.toJwk(key, options.namedCurve, { outputPublic: options.outputPublic })];
              } else
                throw new Error("UnsupportedConversion");
              _a.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.toJwkFrom = toJwkFrom;
  }
});

// node_modules/js-crypto-key-utils/dist/thumbprint.js
var require_thumbprint = __commonJS({
  "node_modules/js-crypto-key-utils/dist/thumbprint.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getJwkThumbprint = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_hash_1 = __importDefault(require_dist4());
    var BufferMod = __importStar(require_buffer());
    var Buffer2 = BufferMod.Buffer;
    var getJwkThumbprint = function(jwkey, alg, output) {
      if (alg === void 0) {
        alg = "SHA-256";
      }
      if (output === void 0) {
        output = "binary";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var jsonString, uint8json, thumbPrintBuf;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (["hex", "binary"].indexOf(output) < 0)
                throw new Error("UnsupportedOutputFormat");
              if (jwkey.kty === "EC") {
                jsonString = JSON.stringify({ crv: jwkey.crv, kty: jwkey.kty, x: jwkey.x, y: jwkey.y });
              } else if (jwkey.kty === "RSA") {
                jsonString = JSON.stringify({ e: jwkey.e, kty: jwkey.kty, n: jwkey.n });
              } else
                throw new Error("UnsupportedKeyType");
              uint8json = new Uint8Array(Buffer2.from(jsonString, "utf8"));
              return [4, js_crypto_hash_1.default.compute(uint8json, alg)];
            case 1:
              thumbPrintBuf = _a.sent();
              if (output === "hex")
                return [2, js_encoding_utils_1.default.encoder.arrayBufferToHexString(thumbPrintBuf)];
              else if (output === "base64")
                return [2, js_encoding_utils_1.default.encoder.encodeBase64(thumbPrintBuf)];
              else
                return [2, thumbPrintBuf];
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.getJwkThumbprint = getJwkThumbprint;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/js-crypto-key-utils/dist/key.js
var require_key = __commonJS({
  "node_modules/js-crypto-key-utils/dist/key.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = void 0;
    var converter_1 = require_converter();
    var thumbprint_1 = require_thumbprint();
    var js_encoding_utils_1 = __importDefault(require_src());
    var util_1 = require_util();
    var cloneDeep = require_lodash();
    var Key = (
      /** @class */
      function() {
        function Key2(format, key, options) {
          if (options === void 0) {
            options = {};
          }
          var localKey = cloneDeep(key);
          var localOpt = cloneDeep(options);
          this._type = null;
          this._jwk = null;
          this._der = null;
          this._oct = {};
          this._isEncrypted = false;
          this._current = { jwk: false, der: false, oct: false };
          if (format === "jwk") {
            this._setJwk(localKey);
          } else if (format === "der" || format === "pem") {
            if (format === "der" && !(localKey instanceof Uint8Array))
              throw new Error("DerKeyMustBeUint8Array");
            if (format === "pem" && typeof localKey !== "string")
              throw new Error("PemKeyMustBeString");
            this._setAsn1(localKey, format);
          } else if (format === "oct") {
            if (typeof localOpt.namedCurve !== "string")
              throw new Error("namedCurveMustBeSpecified");
            if (!(localKey instanceof Uint8Array))
              throw new Error("OctetKeyMustBeUint8Array");
            this._setSec1(localKey, localOpt.namedCurve);
          } else
            throw new Error("UnsupportedType");
        }
        Key2.prototype._setJwk = function(jwkey) {
          this._type = (0, util_1.getJwkType)(jwkey);
          this._jwk = jwkey;
          if (this._isEncrypted)
            this._der = null;
          this._isEncrypted = false;
          this._setCurrentStatus();
        };
        Key2.prototype._setAsn1 = function(asn1key, format) {
          this._type = (0, util_1.isAsn1Public)(asn1key, format) ? "public" : "private";
          this._isEncrypted = (0, util_1.isAsn1Encrypted)(asn1key, format);
          this._der = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(asn1key) : asn1key;
          if (this._isEncrypted) {
            this._jwk = null;
            this._oct = {};
          }
          this._setCurrentStatus();
        };
        Key2.prototype._setSec1 = function(sec1key, namedCurve) {
          this._type = (0, util_1.getSec1KeyType)(sec1key, namedCurve);
          this._oct = { namedCurve, key: sec1key };
          if (this._isEncrypted)
            this._der = null;
          this._isEncrypted = false;
          this._setCurrentStatus();
        };
        Key2.prototype._setCurrentStatus = function() {
          this._current.jwk = this._jwk !== null && (this._jwk.kty === "RSA" || this._jwk.kty === "EC");
          this._current.der = this._der !== null && this._der.length > 0;
          this._current.oct = typeof this._oct.key !== "undefined" && typeof this._oct.namedCurve !== "undefined" && this._oct.key.length > 0;
        };
        Key2.prototype.export = function(format, options) {
          if (format === void 0) {
            format = "jwk";
          }
          if (options === void 0) {
            options = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var jwkey;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (this._isEncrypted && this._type === "private") {
                    if ((format === "der" || format === "pem") && Object.keys(options).length === 0 && this._current.der) {
                      return [2, format === "pem" ? js_encoding_utils_1.default.formatter.binToPem(this._der, "encryptedPrivate") : this._der];
                    } else
                      throw new Error("DecryptionRequired");
                  }
                  if (!this._current.jwk)
                    return [3, 1];
                  jwkey = this._jwk;
                  return [3, 6];
                case 1:
                  if (!this._current.oct)
                    return [3, 3];
                  return [4, (0, converter_1.toJwkFrom)("oct", this._oct.key, { namedCurve: this._oct.namedCurve })];
                case 2:
                  jwkey = _a.sent();
                  return [3, 6];
                case 3:
                  if (!this._current.der)
                    return [3, 5];
                  return [4, (0, converter_1.toJwkFrom)("der", this._der)];
                case 4:
                  jwkey = _a.sent();
                  return [3, 6];
                case 5:
                  throw new Error("InvalidStatus");
                case 6:
                  this._setJwk(jwkey);
                  if (!(format === "der" || format === "pem"))
                    return [3, 8];
                  return [4, (0, converter_1.fromJwkTo)(format, jwkey, {
                    outputPublic: options.outputPublic,
                    compact: options.compact,
                    //passphrase: options.encryptParams.passphrase,
                    encryptParams: options.encryptParams
                  })];
                case 7:
                  return [2, _a.sent()];
                case 8:
                  if (!(format === "oct"))
                    return [3, 10];
                  return [4, (0, converter_1.fromJwkTo)(format, jwkey, {
                    outputPublic: options.outputPublic,
                    output: options.output,
                    compact: options.compact
                  })];
                case 9:
                  return [2, _a.sent()];
                case 10:
                  return [2, jwkey];
              }
            });
          });
        };
        Key2.prototype.encrypt = function(passphrase) {
          return __awaiter(this, void 0, void 0, function() {
            var options, _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this._isEncrypted)
                    throw new Error("AlreadyEncrypted");
                  options = { encryptParams: { passphrase } };
                  _a = this._setAsn1;
                  return [4, this.export("der", options)];
                case 1:
                  _a.apply(this, [_b.sent(), "der"]);
                  return [2, true];
              }
            });
          });
        };
        Key2.prototype.decrypt = function(passphrase) {
          return __awaiter(this, void 0, void 0, function() {
            var jwkey;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this._isEncrypted)
                    throw new Error("NotEncrypted");
                  if (!this._current.der)
                    return [3, 2];
                  return [4, (0, converter_1.toJwkFrom)("der", this._der, { passphrase })];
                case 1:
                  jwkey = _a.sent();
                  return [3, 3];
                case 2:
                  throw new Error("FailedToDecrypt");
                case 3:
                  this._setJwk(jwkey);
                  return [2, true];
              }
            });
          });
        };
        Key2.prototype.getJwkThumbprint = function(alg, output) {
          if (alg === void 0) {
            alg = "SHA-256";
          }
          if (output === void 0) {
            output = "binary";
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this._isEncrypted)
                    throw new Error("DecryptionRequired");
                  _a = thumbprint_1.getJwkThumbprint;
                  return [4, this.export("jwk")];
                case 1:
                  return [4, _a.apply(void 0, [_b.sent(), alg, output])];
                case 2:
                  return [2, _b.sent()];
              }
            });
          });
        };
        Object.defineProperty(Key2.prototype, "keyType", {
          // getters
          /**
           * Get keyType in JWK format
           * @return {Promise<String>} - 'RSA' or 'EC'
           * @throws {Error} - Throws if DecryptionRequired.
           */
          get: function() {
            var _this = this;
            if (this._isEncrypted)
              throw new Error("DecryptionRequired");
            return new Promise(function(resolve, reject) {
              _this.export("jwk").then(function(r) {
                resolve(r.kty);
              }).catch(function(e) {
                reject(e);
              });
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "jwkThumbprint", {
          /**
           * Get jwkThumbprint of this key.
           * @return {Promise<Uint8Array>} - Returns binary thumbprint.
           */
          get: function() {
            return this.getJwkThumbprint();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "isEncrypted", {
          /**
           * Check if this is encrypted.
           * @return {boolean}
           */
          get: function() {
            return this._isEncrypted;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "isPrivate", {
          /**
           * Check if this is a private key.
           * @return {boolean}
           */
          get: function() {
            return this._type === "private";
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "der", {
          /**
           * Returns the key in DER format.
           * @return {Promise<DER>}
           */
          get: function() {
            return this.export("der");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "pem", {
          /**
           * Returns the key in PEM format.
           * @return {Promise<PEM>}
           */
          get: function() {
            return this.export("pem");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "jwk", {
          /**
           * Returns the key in JWK format
           * @return {Promise<JsonWebKey>}
           */
          get: function() {
            return this.export("jwk");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "oct", {
          /**
           * Returns the 'EC' key in Octet SEC1 format.
           * @return {Promise<OctetEC>}
           */
          get: function() {
            return this.export("oct", { output: "string" });
          },
          enumerable: false,
          configurable: true
        });
        return Key2;
      }()
    );
    exports.Key = Key;
  }
});

// node_modules/js-crypto-key-utils/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = void 0;
    var key = __importStar(require_key());
    exports.Key = key.Key;
    exports.default = { Key: exports.Key };
  }
});

export {
  require_src,
  require_dist4 as require_dist,
  require_dist7 as require_dist2
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=chunk-X5RDO3UT.js.map
