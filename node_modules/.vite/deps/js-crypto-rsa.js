import {
  require_dist as require_dist3,
  require_dist2 as require_dist4,
  require_src
} from "./chunk-KIYZQJIJ.js";
import {
  require_dist as require_dist2
} from "./chunk-R6RVWVMA.js";
import "./chunk-XXAOEBEW.js";
import {
  require_dist
} from "./chunk-S6ZVDFYS.js";
import {
  require_bn
} from "./chunk-BTXT6NEL.js";
import "./chunk-NOAZU2D3.js";
import "./chunk-4NEQXOA4.js";
import "./chunk-P2Q7URDJ.js";
import "./chunk-FLCUFOVR.js";
import {
  require_buffer
} from "./chunk-JRORZOUI.js";
import "./chunk-P6XMF7ME.js";
import "./chunk-ZRTRMM6L.js";
import "./chunk-K5E2VSA5.js";
import "./chunk-MUXR4EL6.js";
import {
  __commonJS
} from "./chunk-TDUMLE5V.js";

// node_modules/js-crypto-rsa/dist/webapi.js
var require_webapi = __commonJS({
  "node_modules/js-crypto-rsa/dist/webapi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptRsa = exports.encryptRsa = exports.verifyRsa = exports.signRsa = exports.generateKey = void 0;
    var generateKey = function(modulusLength, publicExponent, webCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var alg, keys, publicKey, privateKey;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              alg = { name: "RSA-OAEP", modulusLength, publicExponent, hash: { name: "SHA-256" } };
              return [4, webCrypto.generateKey(alg, true, ["encrypt", "decrypt"])];
            case 1:
              keys = _a.sent();
              return [4, webCrypto.exportKey("jwk", keys.publicKey)];
            case 2:
              publicKey = _a.sent();
              return [4, webCrypto.exportKey("jwk", keys.privateKey)];
            case 3:
              privateKey = _a.sent();
              delete publicKey.key_ops;
              delete publicKey.alg;
              delete publicKey.ext;
              delete privateKey.key_ops;
              delete privateKey.alg;
              delete privateKey.ext;
              return [2, { publicKey, privateKey }];
          }
        });
      });
    };
    exports.generateKey = generateKey;
    function signRsa(msg, privateJwk, hash, algorithm, webCrypto) {
      return __awaiter(this, void 0, void 0, function() {
        var algo, key, signature;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              algo = { name: algorithm.name, hash: { name: hash }, saltLength: algorithm.saltLength };
              return [4, webCrypto.importKey("jwk", privateJwk, algo, false, ["sign"])];
            case 1:
              key = _a.sent();
              return [4, webCrypto.sign(algo, key, msg)];
            case 2:
              signature = _a.sent();
              return [2, new Uint8Array(signature)];
          }
        });
      });
    }
    exports.signRsa = signRsa;
    var verifyRsa = function(msg, signature, publicJwk, hash, algorithm, webCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var algo, key;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              algo = { name: algorithm.name, hash: { name: hash }, saltLength: algorithm.saltLength };
              return [4, webCrypto.importKey("jwk", publicJwk, algo, false, ["verify"])];
            case 1:
              key = _a.sent();
              return [2, webCrypto.verify(algo, key, signature, msg)];
          }
        });
      });
    };
    exports.verifyRsa = verifyRsa;
    var encryptRsa = function(msg, publicJwk, hash, label, webCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var algo, key, encrypted;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              algo = { name: "RSA-OAEP", hash: { name: hash }, label };
              return [4, webCrypto.importKey("jwk", publicJwk, algo, false, ["encrypt"])];
            case 1:
              key = _a.sent();
              return [4, webCrypto.encrypt(algo, key, msg)];
            case 2:
              encrypted = _a.sent();
              return [2, new Uint8Array(encrypted)];
          }
        });
      });
    };
    exports.encryptRsa = encryptRsa;
    var decryptRsa = function(msg, privateJwk, hash, label, webCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var algo, key, decrypted;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              algo = { name: "RSA-OAEP", hash: { name: hash }, label };
              return [4, webCrypto.importKey("jwk", privateJwk, algo, false, ["decrypt"])];
            case 1:
              key = _a.sent();
              return [4, webCrypto.decrypt(algo, key, msg)];
            case 2:
              decrypted = _a.sent();
              return [2, new Uint8Array(decrypted)];
          }
        });
      });
    };
    exports.decryptRsa = decryptRsa;
  }
});

// node_modules/js-crypto-rsa/dist/params.js
var require_params = __commonJS({
  "node_modules/js-crypto-rsa/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashes = void 0;
    exports.hashes = {
      // maxInput: 2^maxInput - 1 octets
      "SHA-256": { nodeName: "sha256", hashSize: 32, maxInput: 61 },
      "SHA-384": { nodeName: "sha384", hashSize: 48, maxInput: 125 },
      "SHA-512": { nodeName: "sha512", hashSize: 64, maxInput: 125 },
      "SHA-1": { nodeName: "sha1", hashSize: 20, maxInput: 61 }
    };
  }
});

// node_modules/js-crypto-rsa/dist/oaep.js
var require_oaep = __commonJS({
  "node_modules/js-crypto-rsa/dist/oaep.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.emeOaepDecode = exports.emeOaepEncode = exports.checkLength = void 0;
    var params = __importStar(require_params());
    var js_crypto_hash_1 = __importDefault(require_dist3());
    var js_crypto_random_1 = __importDefault(require_dist2());
    var checkLength = function(mode, _a) {
      var k = _a.k, label = _a.label, hash = _a.hash, mLen = _a.mLen, cLen = _a.cLen;
      if (mode === "encrypt") {
        if (label.length > (1 << params.hashes[hash].maxInput) - 1)
          throw new Error("LabelTooLong");
        if (mLen > k - 2 * params.hashes[hash].hashSize - 2)
          throw new Error("MessageTooLong");
      } else if (mode === "decrypt") {
        if (label.length > (1 << params.hashes[hash].maxInput) - 1)
          throw new Error("DecryptionError");
        if (cLen !== k || k < 2 * params.hashes[hash].hashSize + 2)
          throw new Error("DecryptionError");
      } else
        throw new Error("InvalidMode");
    };
    exports.checkLength = checkLength;
    var emeOaepEncode = function(msg, label, k, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var hashSize, ps, lHash, db, seed, dbMask, maskedDb, seedMask, maskedSeed, em;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              hashSize = params.hashes[hash].hashSize;
              ps = new Uint8Array(k - msg.length - 2 * hashSize - 2);
              ps = ps.map(function() {
                return 0;
              });
              return [4, js_crypto_hash_1.default.compute(label, hash)];
            case 1:
              lHash = _a.sent();
              db = new Uint8Array(k - hashSize - 1);
              db.set(lHash);
              db.set(ps, hashSize);
              db.set(new Uint8Array([1]), k - msg.length - hashSize - 2);
              db.set(msg, k - msg.length - hashSize - 1);
              return [4, js_crypto_random_1.default.getRandomBytes(hashSize)];
            case 2:
              seed = _a.sent();
              return [4, mgf1(seed, k - hashSize - 1, hash)];
            case 3:
              dbMask = _a.sent();
              maskedDb = db.map(function(elem, idx) {
                return 255 & (elem ^ dbMask[idx]);
              });
              return [4, mgf1(maskedDb, hashSize, hash)];
            case 4:
              seedMask = _a.sent();
              maskedSeed = seed.map(function(elem, idx) {
                return 255 & (elem ^ seedMask[idx]);
              });
              em = new Uint8Array(k);
              em.set(new Uint8Array([0]));
              em.set(maskedSeed, 1);
              em.set(maskedDb, hashSize + 1);
              return [2, em];
          }
        });
      });
    };
    exports.emeOaepEncode = emeOaepEncode;
    var emeOaepDecode = function(em, label, k, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var hashSize, lHash, y, maskedSeed, maskedDb, seedMask, seed, dbMask, db, lHashPrime, offset, i, separator;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              hashSize = params.hashes[hash].hashSize;
              return [4, js_crypto_hash_1.default.compute(label, hash)];
            case 1:
              lHash = _a.sent();
              y = em[0];
              if (y !== 0)
                throw new Error("DecryptionError");
              maskedSeed = em.slice(1, hashSize + 1);
              maskedDb = em.slice(hashSize + 1, em.length);
              return [4, mgf1(maskedDb, hashSize, hash)];
            case 2:
              seedMask = _a.sent();
              seed = maskedSeed.map(function(elem, idx) {
                return 255 & (elem ^ seedMask[idx]);
              });
              return [4, mgf1(seed, k - hashSize - 1, hash)];
            case 3:
              dbMask = _a.sent();
              db = maskedDb.map(function(elem, idx) {
                return 255 & (elem ^ dbMask[idx]);
              });
              lHashPrime = db.slice(0, hashSize);
              if (lHashPrime.toString() !== lHash.toString())
                throw new Error("DecryptionError");
              offset = 0;
              for (i = hashSize; i < db.length; i++) {
                if (db[i] !== 0) {
                  offset = i;
                  break;
                }
              }
              separator = db[offset];
              if (separator !== 1)
                throw new Error("DecryptionError");
              return [2, db.slice(offset + 1, db.length)];
          }
        });
      });
    };
    exports.emeOaepDecode = emeOaepDecode;
    var mgf1 = function(seed, len, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var hashSize, blockLen, t, i, c, x, y;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              hashSize = params.hashes[hash].hashSize;
              blockLen = Math.ceil(len / hashSize);
              t = new Uint8Array(blockLen * hashSize);
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < blockLen))
                return [3, 4];
              c = i2osp(i, 4);
              x = new Uint8Array(seed.length + 4);
              x.set(seed);
              x.set(c, seed.length);
              return [4, js_crypto_hash_1.default.compute(x, hash)];
            case 2:
              y = _a.sent();
              t.set(y, i * hashSize);
              _a.label = 3;
            case 3:
              i++;
              return [3, 1];
            case 4:
              return [2, t.slice(0, len)];
          }
        });
      });
    };
    var i2osp = function(x, len) {
      var r = new Uint8Array(len);
      r.forEach(function(elem, idx) {
        var y = 255 & x >> idx * 8;
        r[len - idx - 1] = y;
      });
      return r;
    };
  }
});

// node_modules/js-crypto-rsa/dist/nodeapi.js
var require_nodeapi = __commonJS({
  "node_modules/js-crypto-rsa/dist/nodeapi.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptRsa = exports.encryptRsa = exports.verifyRsa = exports.signRsa = exports.generateKey = void 0;
    var params = __importStar(require_params());
    var js_crypto_key_utils_1 = require_dist4();
    var js_encoding_utils_1 = __importDefault(require_src());
    var oaep = __importStar(require_oaep());
    var BN = require_bn();
    require_buffer();
    var generateKey = function(modulusLength, publicExponent, nodeCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pe, options, nodeKeyGen, keyPairDer, publicObj, privateObj;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              pe = new BN(publicExponent);
              options = {
                modulusLength,
                publicExponent: pe.toNumber(),
                publicKeyEncoding: { type: "spki", format: "der" },
                privateKeyEncoding: { type: "pkcs8", format: "der" }
              };
              nodeKeyGen = function() {
                return new Promise(function(resolve, reject) {
                  nodeCrypto.generateKeyPair("rsa", options, function(err, publicKey, privateKey) {
                    if (err)
                      reject("KeyGenerationFailedNode");
                    else
                      resolve({ publicKey, privateKey });
                  });
                });
              };
              return [4, nodeKeyGen().catch(function() {
                throw new Error("KeyGenerationFailedNode");
              })];
            case 1:
              keyPairDer = _b.sent();
              publicObj = new js_crypto_key_utils_1.Key("der", new Uint8Array(keyPairDer.publicKey));
              privateObj = new js_crypto_key_utils_1.Key("der", new Uint8Array(keyPairDer.privateKey));
              _a = {};
              return [4, publicObj.export("jwk")];
            case 2:
              _a.publicKey = _b.sent();
              return [4, privateObj.export("jwk")];
            case 3:
              return [2, (_a.privateKey = _b.sent(), _a)];
          }
        });
      });
    };
    exports.generateKey = generateKey;
    var signRsa = function(msg, privateJwk, hash, algorithm, nodeCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var keyObj, privatePem, signing, opt;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              keyObj = new js_crypto_key_utils_1.Key("jwk", privateJwk);
              if (!keyObj.isPrivate)
                throw new Error("NotPrivateKeyForRSASign");
              return [4, keyObj.export("pem")];
            case 1:
              privatePem = _a.sent();
              signing = nodeCrypto.createSign(params.hashes[hash].nodeName);
              signing.update(msg);
              opt = algorithm.name === "RSA-PSS" ? { saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING } : {};
              return [2, new Uint8Array(signing.sign(Object.assign({ key: privatePem }, opt)))];
          }
        });
      });
    };
    exports.signRsa = signRsa;
    var verifyRsa = function(msg, signature, publicJwk, hash, algorithm, nodeCrypto) {
      return __awaiter(void 0, void 0, void 0, function() {
        var keyObj, publicPem, verify, opt;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              keyObj = new js_crypto_key_utils_1.Key("jwk", publicJwk);
              if (keyObj.isPrivate)
                throw new Error("NotPublicKeyForRSAVerify");
              return [4, keyObj.export("pem", { outputPublic: true })];
            case 1:
              publicPem = _a.sent();
              verify = nodeCrypto.createVerify(params.hashes[hash].nodeName);
              verify.update(msg);
              opt = algorithm.name === "RSA-PSS" ? { saltLength: algorithm.saltLength, padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING } : {};
              return [2, verify.verify(Object.assign({ key: publicPem }, opt), signature)];
          }
        });
      });
    };
    exports.verifyRsa = verifyRsa;
    var encryptRsa = function(msg, publicJwk, hash, label, nodeCrypto) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (label === void 0) {
        label = new Uint8Array([]);
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var keyObj, publicPem, encrypted, em;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              keyObj = new js_crypto_key_utils_1.Key("jwk", publicJwk);
              if (keyObj.isPrivate)
                throw new Error("NotPublicKeyForRSAEncrypt");
              return [4, keyObj.export("pem", { outputPublic: true })];
            case 1:
              publicPem = _a.sent();
              if (!(hash === "SHA-1"))
                return [3, 2];
              encrypted = nodeCrypto.publicEncrypt({ key: publicPem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING }, msg);
              return [3, 4];
            case 2:
              return [4, oaep.emeOaepEncode(msg, label, js_encoding_utils_1.default.encoder.decodeBase64Url(publicJwk.n).length, hash)];
            case 3:
              em = _a.sent();
              encrypted = nodeCrypto.publicEncrypt({ key: publicPem, padding: nodeCrypto.constants.RSA_NO_PADDING }, em);
              _a.label = 4;
            case 4:
              return [2, new Uint8Array(encrypted)];
          }
        });
      });
    };
    exports.encryptRsa = encryptRsa;
    var decryptRsa = function(data, privateJwk, hash, label, nodeCrypto) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (label === void 0) {
        label = new Uint8Array([]);
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var keyObj, privatePem, decrypted, em;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              keyObj = new js_crypto_key_utils_1.Key("jwk", privateJwk);
              if (!keyObj.isPrivate)
                throw new Error("NotPrivateKeyForRSADecrypt");
              return [4, keyObj.export("pem")];
            case 1:
              privatePem = _a.sent();
              if (!(hash === "SHA-1"))
                return [3, 2];
              decrypted = nodeCrypto.privateDecrypt({ key: privatePem, padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING }, data);
              return [3, 4];
            case 2:
              em = nodeCrypto.privateDecrypt({ key: privatePem, padding: nodeCrypto.constants.RSA_NO_PADDING }, data);
              return [4, oaep.emeOaepDecode(new Uint8Array(em), label, js_encoding_utils_1.default.encoder.decodeBase64Url(privateJwk.n).length, hash)];
            case 3:
              decrypted = _a.sent();
              _a.label = 4;
            case 4:
              return [2, new Uint8Array(decrypted)];
          }
        });
      });
    };
    exports.decryptRsa = decryptRsa;
  }
});

// node_modules/js-crypto-rsa/dist/pss.js
var require_pss = __commonJS({
  "node_modules/js-crypto-rsa/dist/pss.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkLength = void 0;
    var params = __importStar(require_params());
    var checkLength = function(mode, _a) {
      var k = _a.k, hash = _a.hash, saltLength = _a.saltLength;
      if (mode === "sign") {
        if (k > (1 << params.hashes[hash].maxInput) - 1)
          throw new Error("Inconsistent");
        if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0)
          throw new Error("EncodingError");
      } else if (mode === "verify") {
        if (k > (1 << params.hashes[hash].maxInput) - 1)
          throw new Error("Inconsistent");
        if (k < params.hashes[hash].hashSize + saltLength + 2 || saltLength < 0)
          throw new Error("Inconsistent");
      } else
        throw new Error("InvalidMode");
    };
    exports.checkLength = checkLength;
  }
});

// node_modules/js-crypto-rsa/dist/rsa.js
var require_rsa = __commonJS({
  "node_modules/js-crypto-rsa/dist/rsa.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.verify = exports.sign = exports.generateKey = void 0;
    var util = __importStar(require_dist());
    var js_encoding_utils_1 = __importDefault(require_src());
    var webapi = __importStar(require_webapi());
    var nodeapi = __importStar(require_nodeapi());
    var params = __importStar(require_params());
    var oaep_1 = require_oaep();
    var pss_1 = require_pss();
    var generateKey = function(modulusLength, publicExponent) {
      if (modulusLength === void 0) {
        modulusLength = 2048;
      }
      if (publicExponent === void 0) {
        publicExponent = new Uint8Array([1, 0, 1]);
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, pure, keyPair, e_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              env = util.getCrypto();
              pure = false;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 7, , 8]);
              if (!(env.name === "webCrypto" && typeof env.crypto.generateKey === "function" && typeof env.crypto.exportKey === "function"))
                return [3, 3];
              return [4, webapi.generateKey(modulusLength, publicExponent, env.crypto)];
            case 2:
              keyPair = _a.sent();
              return [3, 6];
            case 3:
              if (!(env.name === "nodeCrypto"))
                return [3, 5];
              return [4, nodeapi.generateKey(modulusLength, publicExponent, env.crypto)];
            case 4:
              keyPair = _a.sent();
              return [3, 6];
            case 5:
              pure = true;
              throw new Error("UnsupportedPureJsEnvironment");
            case 6:
              return [2, keyPair];
            case 7:
              e_1 = _a.sent();
              if (e_1 instanceof Error) {
                if (pure)
                  throw new Error(e_1.message);
                else
                  throw new Error("UnsupportedEnvironment: ".concat(e_1.message));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.generateKey = generateKey;
    var sign = function(msg, privateJwk, hash, algorithm) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (algorithm === void 0) {
        algorithm = { name: "RSA-PSS", saltLength: params.hashes[hash].hashSize };
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, pure, signature, e_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (privateJwk.kty !== "RSA")
                throw new Error("InvalidJwkRsaKey");
              if (algorithm.name === "RSA-PSS") {
                (0, pss_1.checkLength)("sign", { k: js_encoding_utils_1.default.encoder.decodeBase64Url(privateJwk.n).length, hash, saltLength: algorithm.saltLength });
              }
              env = util.getCrypto();
              pure = false;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 7, , 8]);
              if (!(env.name === "webCrypto" && typeof env.crypto.sign === "function" && typeof env.crypto.importKey === "function"))
                return [3, 3];
              return [4, webapi.signRsa(msg, privateJwk, hash, algorithm, env.crypto)];
            case 2:
              signature = _a.sent();
              return [3, 6];
            case 3:
              if (!(env.name === "nodeCrypto"))
                return [3, 5];
              return [4, nodeapi.signRsa(msg, privateJwk, hash, algorithm, env.crypto)];
            case 4:
              signature = _a.sent();
              return [3, 6];
            case 5:
              pure = true;
              throw new Error("UnsupportedPureJsEnvironment");
            case 6:
              return [2, signature];
            case 7:
              e_2 = _a.sent();
              if (e_2 instanceof Error) {
                if (pure)
                  throw new Error(e_2.message);
                else
                  throw new Error("UnsupportedEnvironment: ".concat(e_2.message));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.sign = sign;
    var verify = function(msg, signature, publicJwk, hash, algorithm) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (algorithm === void 0) {
        algorithm = { name: "RSA-PSS", saltLength: params.hashes[hash].hashSize };
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, pure, valid, e_3;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (publicJwk.kty !== "RSA")
                throw new Error("InvalidJwkRsaKey");
              if (algorithm.name === "RSA-PSS") {
                (0, pss_1.checkLength)("verify", { k: js_encoding_utils_1.default.encoder.decodeBase64Url(publicJwk.n).length, hash, saltLength: algorithm.saltLength });
              }
              env = util.getCrypto();
              pure = false;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 7, , 8]);
              if (!(env.name === "webCrypto" && typeof env.crypto.verify === "function" && typeof env.crypto.importKey === "function"))
                return [3, 3];
              return [4, webapi.verifyRsa(msg, signature, publicJwk, hash, algorithm, env.crypto)];
            case 2:
              valid = _a.sent();
              return [3, 6];
            case 3:
              if (!(env.name === "nodeCrypto"))
                return [3, 5];
              return [4, nodeapi.verifyRsa(msg, signature, publicJwk, hash, algorithm, env.crypto)];
            case 4:
              valid = _a.sent();
              return [3, 6];
            case 5:
              pure = true;
              throw new Error("UnsupportedPureJsEnvironment");
            case 6:
              return [2, valid];
            case 7:
              e_3 = _a.sent();
              if (e_3 instanceof Error) {
                if (pure)
                  throw new Error(e_3.message);
                else
                  throw new Error("UnsupportedEnvironment: ".concat(e_3.message));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.verify = verify;
    var encrypt = function(msg, publicJwk, hash, label) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (label === void 0) {
        label = new Uint8Array([]);
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, pure, encrypted, e_4;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (publicJwk.kty !== "RSA")
                throw new Error("InvalidJwkRsaKey");
              (0, oaep_1.checkLength)("encrypt", { k: js_encoding_utils_1.default.encoder.decodeBase64Url(publicJwk.n).length, label, hash, mLen: msg.length, cLen: 0 });
              env = util.getCrypto();
              pure = false;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 7, , 8]);
              if (!(env.name === "webCrypto" && typeof env.crypto.encrypt === "function" && typeof env.crypto.importKey === "function"))
                return [3, 3];
              return [4, webapi.encryptRsa(msg, publicJwk, hash, label, env.crypto)];
            case 2:
              encrypted = _a.sent();
              return [3, 6];
            case 3:
              if (!(env.name === "nodeCrypto"))
                return [3, 5];
              return [4, nodeapi.encryptRsa(msg, publicJwk, hash, label, env.crypto)];
            case 4:
              encrypted = _a.sent();
              return [3, 6];
            case 5:
              pure = true;
              throw new Error("UnsupportedPureJsEnvironment");
            case 6:
              return [2, encrypted];
            case 7:
              e_4 = _a.sent();
              if (e_4 instanceof Error) {
                if (pure)
                  throw new Error(e_4.message);
                else
                  throw new Error("UnsupportedEnvironment: ".concat(e_4.message));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, privateJwk, hash, label) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      if (label === void 0) {
        label = new Uint8Array([]);
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, pure, decrypted, e_5;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (privateJwk.kty !== "RSA")
                throw new Error("InvalidJwkRsaKey");
              (0, oaep_1.checkLength)("decrypt", { k: js_encoding_utils_1.default.encoder.decodeBase64Url(privateJwk.n).length, label, hash, mLen: 0, cLen: data.length });
              env = util.getCrypto();
              pure = false;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 7, , 8]);
              if (!(env.name === "webCrypto" && typeof env.crypto.decrypt === "function" && typeof env.crypto.importKey === "function"))
                return [3, 3];
              return [4, webapi.decryptRsa(data, privateJwk, hash, label, env.crypto)];
            case 2:
              decrypted = _a.sent();
              return [3, 6];
            case 3:
              if (!(env.name === "nodeCrypto"))
                return [3, 5];
              return [4, nodeapi.decryptRsa(data, privateJwk, hash, label, env.crypto)];
            case 4:
              decrypted = _a.sent();
              return [3, 6];
            case 5:
              pure = true;
              throw new Error("UnsupportedPureJsEnvironment");
            case 6:
              return [2, decrypted];
            case 7:
              e_5 = _a.sent();
              if (e_5 instanceof Error) {
                if (pure)
                  throw new Error(e_5.message);
                else
                  throw new Error("UnsupportedEnvironment: ".concat(e_5.message));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.decrypt = decrypt;
  }
});

// node_modules/js-crypto-rsa/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/js-crypto-rsa/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.verify = exports.sign = exports.generateKey = void 0;
    var rsa = __importStar(require_rsa());
    exports.generateKey = rsa.generateKey;
    exports.sign = rsa.sign;
    exports.verify = rsa.verify;
    exports.encrypt = rsa.encrypt;
    exports.decrypt = rsa.decrypt;
    exports.default = { generateKey: exports.generateKey, sign: exports.sign, verify: exports.verify, encrypt: exports.encrypt, decrypt: exports.decrypt };
  }
});
export default require_dist5();
//# sourceMappingURL=js-crypto-rsa.js.map
