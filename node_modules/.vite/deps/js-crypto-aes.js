import {
  require_crypto
} from "./chunk-P6XMF7ME.js";
import {
  __commonJS
} from "./chunk-TDUMLE5V.js";

// node_modules/js-crypto-env/dist/index.js
var require_dist = __commonJS({
  "node_modules/js-crypto-env/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCrypto = exports.getRootWebCrypto = exports.getWebCrypto = exports.getNodeCrypto = void 0;
    var getNodeCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return void 0;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return void 0;
      } else
        return require_crypto();
    };
    exports.getNodeCrypto = getNodeCrypto;
    var getWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto.subtle;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto.subtle;
      }
      return void 0;
    };
    exports.getWebCrypto = getWebCrypto;
    var getRootWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto;
      }
      return void 0;
    };
    exports.getRootWebCrypto = getRootWebCrypto;
    var getCrypto = function() {
      var webCrypto = getWebCrypto();
      var nodeCrypto = getNodeCrypto();
      if (typeof nodeCrypto !== "undefined")
        return { name: "nodeCrypto", crypto: nodeCrypto };
      else if (typeof webCrypto !== "undefined")
        return { name: "webCrypto", crypto: webCrypto };
      else
        return { name: void 0 };
    };
    exports.getCrypto = getCrypto;
    exports.default = { getNodeCrypto, getWebCrypto, getRootWebCrypto, getCrypto };
  }
});

// node_modules/js-crypto-aes/dist/params.js
var require_params = __commonJS({
  "node_modules/js-crypto-aes/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ciphers = {
      "AES-GCM": {
        nodePrefix: "aes-",
        nodeSuffix: "-gcm",
        ivLength: 12,
        tagLength: 16,
        staticIvLength: true
        // if true, IV length must be always ivLength.
      },
      "AES-CBC": {
        nodePrefix: "aes-",
        nodeSuffix: "-cbc",
        ivLength: 16,
        staticIvLength: true
      },
      "AES-CTR": {
        nodePrefix: "aes-",
        nodeSuffix: "-ctr",
        ivLength: 12,
        staticIvLength: false
      }
    };
    var wrapKeys = {
      "AES-KW": {
        nodePrefix: "id-aes",
        nodeSuffix: "-wrap",
        ivLength: 8,
        staticIvLength: true,
        defaultIv: new Uint8Array([166, 166, 166, 166, 166, 166, 166, 166])
      }
    };
    exports.default = { ciphers, wrapKeys };
  }
});

// node_modules/js-crypto-aes/dist/nodeapi.js
var require_nodeapi = __commonJS({
  "node_modules/js-crypto-aes/dist/nodeapi.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;
    var params_1 = __importDefault(require_params());
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a, nodeCrypto) {
      var name = _a.name, iv = _a.iv;
      return (0, exports.encrypt)(keyToBeWrapped, wrappingKey, { name, iv }, nodeCrypto, true);
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, unwrappingKey, _a, nodeCrypto) {
      var name = _a.name, iv = _a.iv;
      return (0, exports.decrypt)(wrappedKey, unwrappingKey, { name, iv }, nodeCrypto, true);
    };
    exports.unwrapKey = unwrapKey;
    var encrypt = function(msg, key, _a, nodeCrypto, wrapKey2) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      if (wrapKey2 === void 0) {
        wrapKey2 = false;
      }
      var alg = getNodeName(name, key.byteLength, wrapKey2 ? params_1.default.wrapKeys : params_1.default.ciphers);
      var cipher;
      switch (name) {
        case "AES-GCM": {
          cipher = nodeCrypto.createCipheriv(alg, key, iv, { authTagLength: tagLength });
          cipher.setAAD(additionalData);
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          var counter = new Uint8Array(16);
          counter.set(iv);
          counter[15] += 1;
          cipher = nodeCrypto.createCipheriv(alg, key, counter);
          break;
        }
        default: {
          cipher = nodeCrypto.createCipheriv(alg, key, iv);
          break;
        }
      }
      var body;
      var final;
      var tag;
      try {
        body = new Uint8Array(cipher.update(msg));
        final = new Uint8Array(cipher.final());
        tag = new Uint8Array([]);
        if (name === "AES-GCM")
          tag = new Uint8Array(cipher.getAuthTag());
      } catch (e) {
        throw new Error("NodeCrypto_EncryptionFailure");
      }
      var data = new Uint8Array(body.length + final.length + tag.length);
      data.set(body);
      data.set(final, body.length);
      data.set(tag, body.length + final.length);
      return data;
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a, nodeCrypto, unwrapKey2) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      if (unwrapKey2 === void 0) {
        unwrapKey2 = false;
      }
      var alg = getNodeName(name, key.byteLength, unwrapKey2 ? params_1.default.wrapKeys : params_1.default.ciphers);
      var decipher;
      var body;
      switch (name) {
        case "AES-GCM": {
          decipher = nodeCrypto.createDecipheriv(alg, key, iv, { authTagLength: tagLength });
          decipher.setAAD(additionalData);
          body = data.slice(0, data.length - tagLength);
          var tag = data.slice(data.length - tagLength);
          decipher.setAuthTag(tag);
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          var counter = new Uint8Array(16);
          counter.set(iv);
          counter[15] += 1;
          decipher = nodeCrypto.createDecipheriv(alg, key, counter);
          body = data;
          break;
        }
        default: {
          decipher = nodeCrypto.createDecipheriv(alg, key, iv);
          body = data;
          break;
        }
      }
      var decryptedBody;
      var final;
      try {
        decryptedBody = decipher.update(body);
        final = decipher.final();
      } catch (e) {
        throw new Error("NodeCrypto_DecryptionFailure");
      }
      var msg = new Uint8Array(final.length + decryptedBody.length);
      msg.set(decryptedBody);
      msg.set(final, decryptedBody.length);
      return msg;
    };
    exports.decrypt = decrypt;
    var getNodeName = function(name, keyLength, dict) {
      var alg = dict[name].nodePrefix;
      alg = "".concat(alg).concat((keyLength * 8).toString());
      return alg + dict[name].nodeSuffix;
    };
  }
});

// node_modules/js-crypto-aes/dist/webapi.js
var require_webapi = __commonJS({
  "node_modules/js-crypto-aes/dist/webapi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a, webCrypto) {
      var name = _a.name, iv = _a.iv;
      return __awaiter(void 0, void 0, void 0, function() {
        var kek, cek, data, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", wrappingKey, { name }, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _b.sent();
              return [4, webCrypto.importKey("raw", keyToBeWrapped, { name }, true, ["wrapKey", "unwrapKey"])];
            case 2:
              cek = _b.sent();
              return [4, webCrypto.wrapKey("raw", cek, kek, { name, iv })];
            case 3:
              data = _b.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_1 = _b.sent();
              if (e_1 instanceof Error) {
                throw new Error("WebCrypto_FailedToWrapKey - ".concat(e_1.message));
              } else {
                throw new Error("WebCrypto_FailedToWrapKey");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, unwrappingKey, _a, webCrypto) {
      var name = _a.name, iv = _a.iv;
      return __awaiter(void 0, void 0, void 0, function() {
        var kek, cek, _b, e_2;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", unwrappingKey, { name }, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _c.sent();
              return [4, webCrypto.unwrapKey("raw", wrappedKey, kek, { name, iv }, { name: "AES-GCM" }, true, ["encrypt", "decrypt"])];
            case 2:
              cek = _c.sent();
              _b = Uint8Array.bind;
              return [4, webCrypto.exportKey("raw", cek)];
            case 3:
              return [2, new (_b.apply(Uint8Array, [void 0, _c.sent()]))()];
            case 4:
              e_2 = _c.sent();
              if (e_2 instanceof Error) {
                throw new Error("WebCrypto_FailedToUnwrapKey - ".concat(e_2.message));
              } else {
                throw new Error("WebCrypto_FailedToUnwrapKey");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.unwrapKey = unwrapKey;
    var encrypt = function(msg, key, _a, webCrypto) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var encryptionConfig, sessionKeyObj, data, e_3;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              encryptionConfig = setCipherParams({ name, iv, additionalData, tagLength });
              _c.label = 1;
            case 1:
              _c.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key, encryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _c.sent();
              return [4, webCrypto.encrypt(encryptionConfig, sessionKeyObj, msg)];
            case 3:
              data = _c.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_3 = _c.sent();
              if (e_3 instanceof Error) {
                throw new Error("WebCrypto_EncryptionFailure: ".concat(e_3.message));
              } else {
                throw new Error("WebCrypto_EncryptionFailure");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a, webCrypto) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var decryptionConfig, sessionKeyObj, msg, e_4;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              decryptionConfig = setCipherParams({ name, iv, additionalData, tagLength });
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key, decryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _b.sent();
              return [4, webCrypto.decrypt(decryptionConfig, sessionKeyObj, data)];
            case 3:
              msg = _b.sent();
              return [2, new Uint8Array(msg)];
            case 4:
              e_4 = _b.sent();
              if (e_4 instanceof Error) {
                throw new Error("WebCrypto_DecryptionFailure: ".concat(e_4.message));
              } else {
                throw new Error("WebCrypto_DecryptionFailure");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.decrypt = decrypt;
    var setCipherParams = function(_a) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      var alg = { name, iv, additionalData, tagLength };
      switch (name) {
        case "AES-GCM": {
          alg.tagLength = tagLength * 8;
          break;
        }
        case "AES-CBC": {
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          alg.counter = new Uint8Array(16);
          alg.counter.set(iv);
          alg.counter[15] += 1;
          alg.length = 128;
          break;
        }
      }
      return alg;
    };
  }
});

// node_modules/js-crypto-aes/dist/aes.js
var require_aes = __commonJS({
  "node_modules/js-crypto-aes/dist/aes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;
    var util = __importStar(require_dist());
    var nodeapi = __importStar(require_nodeapi());
    var webapi = __importStar(require_webapi());
    var params_1 = __importDefault(require_params());
    var assertAlgorithms = function(_a) {
      var name = _a.name, iv = _a.iv, tagLength = _a.tagLength;
      if (params_1.default.ciphers[name].ivLength) {
        if (!(iv instanceof Uint8Array))
          throw new Error("InvalidArguments");
        if (iv.byteLength < 2 || iv.byteLength > 16)
          throw new Error("InvalidIVLength");
        if (params_1.default.ciphers[name].staticIvLength && params_1.default.ciphers[name].ivLength !== iv.byteLength)
          throw new Error("InvalidIVLength");
      }
      if (params_1.default.ciphers[name].tagLength && tagLength) {
        if (!Number.isInteger(tagLength))
          throw new Error("InvalidArguments");
        if (tagLength < 4 || tagLength > 16)
          throw new Error("InvalidTagLength");
      }
    };
    var encrypt = function(msg, key, _a) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env;
        return __generator(this, function(_d) {
          assertAlgorithms({ name, iv, tagLength });
          if (params_1.default.ciphers[name].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name].tagLength;
          env = util.getCrypto();
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.encrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.encrypt(msg, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.encrypt(msg, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env;
        return __generator(this, function(_d) {
          assertAlgorithms({ name, iv, tagLength });
          if (params_1.default.ciphers[name].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name].tagLength;
          env = util.getCrypto();
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.decrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.decrypt(data, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.decrypt(data, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.decrypt = decrypt;
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a) {
      var name = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env, iv;
        return __generator(this, function(_b) {
          if (keyToBeWrapped.length % 8 > 0)
            throw new Error("WrappedKeyMustBeMultipleOf8");
          env = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.wrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.wrapKey(keyToBeWrapped, wrappingKey, { name, iv }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.wrapKey(keyToBeWrapped, wrappingKey, { name, iv }, env.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, wrappingKey, _a) {
      var name = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env, iv;
        return __generator(this, function(_b) {
          env = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.unwrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.unwrapKey(wrappedKey, wrappingKey, { name, iv }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.unwrapKey(wrappedKey, wrappingKey, { name, iv }, env.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.unwrapKey = unwrapKey;
  }
});

// node_modules/js-crypto-aes/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/js-crypto-aes/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;
    var aes = __importStar(require_aes());
    exports.encrypt = aes.encrypt;
    exports.decrypt = aes.decrypt;
    exports.wrapKey = aes.wrapKey;
    exports.unwrapKey = aes.unwrapKey;
    exports.default = { encrypt: exports.encrypt, decrypt: exports.decrypt, wrapKey: exports.wrapKey, unwrapKey: exports.unwrapKey };
  }
});
export default require_dist2();
//# sourceMappingURL=js-crypto-aes.js.map
