import {
  require_safe_buffer
} from "./chunk-LHOYWROW.js";
import {
  require_elliptic
} from "./chunk-NOAZU2D3.js";
import {
  require_asn1
} from "./chunk-4NEQXOA4.js";
import "./chunk-P2Q7URDJ.js";
import "./chunk-FLCUFOVR.js";
import "./chunk-JRORZOUI.js";
import "./chunk-P6XMF7ME.js";
import "./chunk-K5E2VSA5.js";
import "./chunk-MUXR4EL6.js";
import {
  __commonJS
} from "./chunk-TDUMLE5V.js";

// node_modules/jwk-to-pem/src/b64-to-bn.js
var require_b64_to_bn = __commonJS({
  "node_modules/jwk-to-pem/src/b64-to-bn.js"(exports, module) {
    "use strict";
    var BN = require_asn1().bignum;
    var Buffer = require_safe_buffer().Buffer;
    module.exports = function base64ToBigNum(val, zero) {
      var buf = Buffer.from(val, "base64");
      var bn = val = new BN(buf, 10, "be").iabs();
      if (zero) {
        buf.fill(0);
      }
      return bn;
    };
  }
});

// node_modules/jwk-to-pem/src/asn1/algorithm-identifier.js
var require_algorithm_identifier = __commonJS({
  "node_modules/jwk-to-pem/src/asn1/algorithm-identifier.js"(exports, module) {
    "use strict";
    module.exports = require_asn1().define(
      "AlgorithmIdentifer",
      /* @this */
      function() {
        this.seq().obj(
          this.key("algorithm").objid(),
          this.key("parameters").optional().any()
        );
      }
    );
  }
});

// node_modules/jwk-to-pem/src/asn1/public-key-info.js
var require_public_key_info = __commonJS({
  "node_modules/jwk-to-pem/src/asn1/public-key-info.js"(exports, module) {
    "use strict";
    var AlgorithmIdentifier = require_algorithm_identifier();
    module.exports = require_asn1().define(
      "PublicKeyInfo",
      /* @this */
      function() {
        this.seq().obj(
          this.key("algorithm").use(AlgorithmIdentifier),
          this.key("PublicKey").bitstr()
        );
      }
    );
  }
});

// node_modules/jwk-to-pem/src/asn1/version.js
var require_version = __commonJS({
  "node_modules/jwk-to-pem/src/asn1/version.js"(exports, module) {
    "use strict";
    module.exports = require_asn1().define(
      "Version",
      /* @this */
      function() {
        this.int();
      }
    );
  }
});

// node_modules/jwk-to-pem/src/asn1/private-key-info.js
var require_private_key_info = __commonJS({
  "node_modules/jwk-to-pem/src/asn1/private-key-info.js"(exports, module) {
    "use strict";
    var AlgorithmIdentifier = require_algorithm_identifier();
    var Version = require_version();
    module.exports = require_asn1().define(
      "PrivateKeyInfo",
      /* @this */
      function() {
        this.seq().obj(
          this.key("version").use(Version),
          this.key("privateKeyAlgorithm").use(AlgorithmIdentifier),
          this.key("privateKey").octstr(),
          this.key("attributes").optional().any()
        );
      }
    );
  }
});

// node_modules/jwk-to-pem/src/ec.js
var require_ec = __commonJS({
  "node_modules/jwk-to-pem/src/ec.js"(exports, module) {
    "use strict";
    var asn1 = require_asn1();
    var Buffer = require_safe_buffer().Buffer;
    var EC = require_elliptic().ec;
    var b64ToBn = require_b64_to_bn();
    var PublicKeyInfo = require_public_key_info();
    var PrivateKeyInfo = require_private_key_info();
    var Version = require_version();
    var ECParameters = asn1.define(
      "ECParameters",
      /* @this */
      function() {
        this.choice({
          namedCurve: this.objid()
        });
      }
    );
    var ecPrivkeyVer1 = 1;
    var ECPrivateKey = asn1.define(
      "ECPrivateKey",
      /* @this */
      function() {
        this.seq().obj(
          this.key("version").use(Version),
          this.key("privateKey").octstr(),
          this.key("parameters").explicit(0).optional().any(),
          this.key("publicKey").explicit(1).optional().bitstr()
        );
      }
    );
    var curves = {
      "P-256": "p256",
      "P-384": "p384",
      "P-521": "p521"
    };
    var oids = {
      "P-256": [1, 2, 840, 10045, 3, 1, 7],
      "P-384": [1, 3, 132, 0, 34],
      "P-521": [1, 3, 132, 0, 35]
    };
    var parameters = {};
    var algorithms = {};
    Object.keys(oids).forEach(function(crv) {
      parameters[crv] = ECParameters.encode({
        type: "namedCurve",
        value: oids[crv]
      }, "der");
      algorithms[crv] = {
        algorithm: [1, 2, 840, 10045, 2, 1],
        parameters: parameters[crv]
      };
    });
    oids = null;
    function ecJwkToBuffer(jwk, opts) {
      if ("string" !== typeof jwk.crv) {
        throw new TypeError('Expected "jwk.crv" to be a String');
      }
      var hasD = "string" === typeof jwk.d;
      var xyTypes = hasD ? ["undefined", "string"] : ["string"];
      if (-1 === xyTypes.indexOf(typeof jwk.x)) {
        throw new TypeError('Expected "jwk.x" to be a String');
      }
      if (-1 === xyTypes.indexOf(typeof jwk.y)) {
        throw new TypeError('Expected "jwk.y" to be a String');
      }
      if (opts.private && !hasD) {
        throw new TypeError('Expected "jwk.d" to be a String');
      }
      var curveName = curves[jwk.crv];
      if (!curveName) {
        throw new Error('Unsupported curve "' + jwk.crv + '"');
      }
      var curve = new EC(curveName);
      var key = {};
      var hasPub = jwk.x && jwk.y;
      if (hasPub) {
        key.pub = {
          x: b64ToBn(jwk.x, false),
          y: b64ToBn(jwk.y, false)
        };
      }
      if (opts.private || !hasPub) {
        key.priv = b64ToBn(jwk.d, true);
      }
      key = curve.keyPair(key);
      var keyValidation = key.validate();
      if (!keyValidation.result) {
        throw new Error('Invalid key for curve: "' + keyValidation.reason + '"');
      }
      var result = keyToPem(jwk.crv, key, opts);
      return result;
    }
    function keyToPem(crv, key, opts) {
      var compact = false;
      var publicKey = key.getPublic(compact, "hex");
      publicKey = Buffer.from(publicKey, "hex");
      publicKey = {
        unused: 0,
        data: publicKey
      };
      var result;
      if (opts.private) {
        var privateKey = key.getPrivate("hex");
        privateKey = Buffer.from(privateKey, "hex");
        result = PrivateKeyInfo.encode({
          version: 0,
          privateKeyAlgorithm: algorithms[crv],
          privateKey: ECPrivateKey.encode({
            version: ecPrivkeyVer1,
            privateKey,
            parameters: parameters[crv],
            publicKey
          }, "der")
        }, "pem", {
          label: "PRIVATE KEY"
        });
        privateKey.fill(0);
      } else {
        result = PublicKeyInfo.encode({
          algorithm: algorithms[crv],
          PublicKey: publicKey
        }, "pem", {
          label: "PUBLIC KEY"
        });
      }
      if ("\n" !== result.slice(-1)) {
        result += "\n";
      }
      return result;
    }
    module.exports = ecJwkToBuffer;
  }
});

// node_modules/jwk-to-pem/src/rsa.js
var require_rsa = __commonJS({
  "node_modules/jwk-to-pem/src/rsa.js"(exports, module) {
    "use strict";
    var asn1 = require_asn1();
    var b64ToBn = require_b64_to_bn();
    var PublicKeyInfo = require_public_key_info();
    var PrivateKeyInfo = require_private_key_info();
    var Version = require_version();
    var RSAPrivateKey = asn1.define(
      "RSAPrivateKey",
      /* @this */
      function() {
        this.seq().obj(
          this.key("version").use(Version),
          this.key("modulus").int(),
          this.key("publicExponent").int(),
          this.key("privateExponent").int(),
          this.key("prime1").int(),
          this.key("prime2").int(),
          this.key("exponent1").int(),
          this.key("exponent2").int(),
          this.key("coefficient").int()
        );
      }
    );
    var RSAPublicKey = asn1.define(
      "RSAPublicKey",
      /* @this */
      function() {
        this.seq().obj(
          this.key("modulus").int(),
          this.key("publicExponent").int()
        );
      }
    );
    var algorithm = {
      algorithm: [1, 2, 840, 113549, 1, 1, 1],
      parameters: [5, 0]
    };
    function rsaJwkToBuffer(jwk, opts) {
      if ("string" !== typeof jwk.e) {
        throw new TypeError('Expected "jwk.e" to be a String');
      }
      if ("string" !== typeof jwk.n) {
        throw new TypeError('Expected "jwk.n" to be a String');
      }
      if (opts.private) {
        if ("string" !== typeof jwk.d) {
          throw new TypeError('Expected "jwk.d" to be a String');
        }
        if ("string" !== typeof jwk.p) {
          throw new TypeError('Expected "jwk.p" to be a String');
        }
        if ("string" !== typeof jwk.q) {
          throw new TypeError('Expected "jwk.q" to be a String');
        }
        if ("string" !== typeof jwk.dp) {
          throw new TypeError('Expected "jwk.dp" to be a String');
        }
        if ("string" !== typeof jwk.dq) {
          throw new TypeError('Expected "jwk.dq" to be a String');
        }
        if ("string" !== typeof jwk.qi) {
          throw new TypeError('Expected "jwk.qi" to be a String');
        }
      }
      var pem;
      if (opts.private) {
        pem = PrivateKeyInfo.encode({
          version: 0,
          privateKeyAlgorithm: algorithm,
          privateKey: RSAPrivateKey.encode({
            version: 0,
            modulus: b64ToBn(jwk.n, false),
            publicExponent: b64ToBn(jwk.e, false),
            privateExponent: b64ToBn(jwk.d, true),
            prime1: b64ToBn(jwk.p, true),
            prime2: b64ToBn(jwk.q, true),
            exponent1: b64ToBn(jwk.dp, true),
            exponent2: b64ToBn(jwk.dq, true),
            coefficient: b64ToBn(jwk.qi, true)
          }, "der")
        }, "pem", {
          label: "PRIVATE KEY"
        });
      } else {
        pem = PublicKeyInfo.encode({
          algorithm,
          PublicKey: {
            unused: 0,
            data: RSAPublicKey.encode({
              modulus: b64ToBn(jwk.n, false),
              publicExponent: b64ToBn(jwk.e, false)
            }, "der")
          }
        }, "pem", {
          label: "PUBLIC KEY"
        });
      }
      if ("\n" !== pem.slice(-1)) {
        pem += "\n";
      }
      return pem;
    }
    module.exports = rsaJwkToBuffer;
  }
});

// node_modules/jwk-to-pem/src/jwk-to-pem.js
var require_jwk_to_pem = __commonJS({
  "node_modules/jwk-to-pem/src/jwk-to-pem.js"(exports, module) {
    var ec = require_ec();
    var rsa = require_rsa();
    function jwkToBuffer(jwk, opts) {
      if ("object" !== typeof jwk || null === jwk) {
        throw new TypeError('Expected "jwk" to be an Object');
      }
      var kty = jwk.kty;
      if ("string" !== typeof kty) {
        throw new TypeError('Expected "jwk.kty" to be a String');
      }
      opts = opts || {};
      opts.private = opts.private === true;
      switch (kty) {
        case "EC": {
          return ec(jwk, opts);
        }
        case "RSA": {
          return rsa(jwk, opts);
        }
        default: {
          throw new Error('Unsupported key type "' + kty + '"');
        }
      }
    }
    module.exports = jwkToBuffer;
  }
});
export default require_jwk_to_pem();
//# sourceMappingURL=jwk-to-pem.js.map
